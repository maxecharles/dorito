{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"dorito","text":"<p><code>dorito</code> is an image reconstruction framework designed to interface with <code>amigo</code>, an end-to-end differentiable forward-modelling pipeline for analysing data from the Aperture Masking Interferometer (AMI) observing mode of the James Webb Space Telescope (JWST).</p> <p>Seen in the gif above are five successive images of Jupiter's moon Io that have been deconvolved with <code>dorito</code>, with the moon's axial rotation clearly visible. The right image shows the expected positions of known volcanic features on Io's hellscape of a surface!</p> <p>Please refer to our publications for more detail: amigo paper here, dorito paper here.</p> <p>We are working hard to create more documentation and example notebooks to share with the community here. Thank you for your patience, and please do not hesitate to reach out with any questions or queries. You can reach me (Max) at <pre><code>max.charles@sydney.edu.au\n</code></pre></p>"},{"location":"docs/api/","title":"API","text":"<p>This page documents the <code>dorito</code> public API generated from the package docstrings. The API pages below are generated by <code>mkdocstrings</code> using the Python handler (NumPy docstring style is configured in <code>mkdocs.yml</code>).</p>"},{"location":"docs/api/#model-fits","title":"Model Fits","text":"<p>Fitting helpers and ModelFit subclasses for resolved sources.</p> <p>This module provides ModelFit classes for fitting resolved sources using amigo, including utilities to handle the log distribution parameter, rotation by parallactic angle, and simulation of resolved source interferograms.</p>"},{"location":"docs/api/#dorito.model_fits.ResolvedFit","title":"<code>ResolvedFit</code>","text":"<p>               Bases: <code>_BaseResolvedFit</code>, <code>ModelFit</code></p> <p>Model fit for resolved (extended) sources.</p> <p>This class extends :class:<code>amigo.model_fits.ModelFit</code> to add support for a spatial distribution parameter (kept as its base-10 logarithm, stored under the key <code>log_dist</code>). It supplies sensible default initialisation and maps the <code>log_dist</code> parameter into the expected keyed parameter namespace for per-filter fitting.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str or path - like</code> <p>Path to the data file or exposure to be passed to :class:<code>ModelFit</code>.</p> required <code>use_cov</code> <code>bool</code> <p>Whether to use the covariance information from the data, by default <code>True</code>.</p> required Source code in <code>src/dorito/model_fits.py</code> <pre><code>class ResolvedFit(_BaseResolvedFit, ModelFit):\n    \"\"\"Model fit for resolved (extended) sources.\n\n    This class extends :class:`amigo.model_fits.ModelFit` to add support for a\n    spatial distribution parameter (kept as its base-10 logarithm, stored\n    under the key ``log_dist``). It supplies sensible default initialisation\n    and maps the ``log_dist`` parameter into the expected keyed parameter\n    namespace for per-filter fitting.\n\n    Parameters\n    ----------\n    file : str or path-like\n        Path to the data file or exposure to be passed to :class:`ModelFit`.\n    use_cov : bool, optional\n        Whether to use the covariance information from the data, by default\n        ``True``.\n    \"\"\"\n\n    def get_key(self, param):\n        match param:\n            case \"log_dist\":\n                return self.filter\n\n        return super().get_key(param)\n\n    def map_param(self, param):\n        match param:\n            case \"log_dist\":\n                return f\"{param}.{self.get_key(param)}\"\n\n        return super().map_param(param)\n\n    def initialise_params(self, optics, distribution):\n\n        params = super().initialise_params(optics)\n\n        # log distribution\n        params[\"log_dist\"] = (\n            self.get_key(\"log_dist\"),\n            np.log10(distribution / distribution.sum()),\n        )\n\n        return params\n\n    def model_interferogram(\n        self,\n        psf,\n        model,\n        rotate: bool = None,\n    ):\n        return psf.convolve(model.get_distribution(self, rotate=rotate), method=\"fft\")\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.DynamicResolvedFit","title":"<code>DynamicResolvedFit</code>","text":"<p>               Bases: <code>ResolvedFit</code></p> <p>Resolved fit where each exposure has its own distribution.</p> <p>For time-series or sequence data where every exposure can have an independent resolved-source distribution, this class modifies the parameter keying so that distribution parameters are unique per exposure (the key includes the exposure <code>self.key</code> and the filter).</p> Notes <p>Only the keying behaviour differs from :class:<code>ResolvedFit</code> \u2014 the underlying parameter representation and simulation pipeline remain the same.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class DynamicResolvedFit(ResolvedFit):\n    \"\"\"Resolved fit where each exposure has its own distribution.\n\n    For time-series or sequence data where every exposure can have an\n    independent resolved-source distribution, this class modifies the\n    parameter keying so that distribution parameters are unique per\n    exposure (the key includes the exposure ``self.key`` and the filter).\n\n    Notes\n    -----\n    Only the keying behaviour differs from :class:`ResolvedFit` \u2014 the\n    underlying parameter representation and simulation pipeline remain the\n    same.\n    \"\"\"\n\n    def get_key(self, param):\n        match param:\n            case \"log_dist\":\n                return \"_\".join([self.key, self.filter])\n\n        return super().get_key(param)\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.TransformedResolvedFit","title":"<code>TransformedResolvedFit</code>","text":"<p>               Bases: <code>ResolvedFit</code></p> <p>Resolved-source fit using coefficients describing a transformed basis.</p> <p>This variant initialises the <code>log_dist</code> parameter from a set of coefficients (for example a set of basis coefficients or a compressed representation) rather than from an explicit full image distribution.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class TransformedResolvedFit(ResolvedFit):\n    \"\"\"Resolved-source fit using coefficients describing a transformed basis.\n\n    This variant initialises the ``log_dist`` parameter from a set of\n    coefficients (for example a set of basis coefficients or a compressed\n    representation) rather than from an explicit full image distribution.\n\n    \"\"\"\n\n    def initialise_params(self, optics, coeffs):\n\n        params = ModelFit.initialise_params(self, optics)\n\n        # log distribution\n        params[\"log_dist\"] = (self.get_key(\"log_dist\"), coeffs)\n\n        return params\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.PointResolvedFit","title":"<code>PointResolvedFit</code>","text":"<p>               Bases: <code>TransformedResolvedFit</code></p> <p>Resolved fit combining an unresolved point-like component and an extended component.</p> <p>This fit represents the source as a superposition of a point source component and a resolved (extended) component. This is useful for modelling systems like young stars with extended protoplanetary disks.</p> Notes <p>Parameters for building the transformed/resolved component are described on :meth:<code>initialise_params</code> (for example <code>optics</code>, <code>coeffs</code> and <code>contrast</code> are the arguments used when initialising parameters).</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class PointResolvedFit(TransformedResolvedFit):\n    \"\"\"Resolved fit combining an unresolved point-like component and an extended component.\n\n    This fit represents the source as a superposition of a point source\n    component and a resolved (extended) component. This is useful for\n    modelling systems like young stars with extended protoplanetary disks.\n\n    Notes\n    -----\n    Parameters for building the transformed/resolved component are described\n    on :meth:`initialise_params` (for example ``optics``, ``coeffs`` and\n    ``contrast`` are the arguments used when initialising parameters).\n    \"\"\"\n\n    def get_key(self, param):\n\n        match param:\n            case \"contrast\":\n                return self.filter\n\n        return super().get_key(param)\n\n    def map_param(self, param):\n\n        # Map the appropriate parameter to the correct key\n        if param in [\"contrast\"]:\n            return f\"{param}.{self.get_key(param)}\"\n\n        # Else its global\n        return super().map_param(param)\n\n    def initialise_params(self, optics, coeffs, contrast):\n\n        params = ModelFit.initialise_params(self, optics)\n\n        # log distribution\n        params[\"log_dist\"] = (self.get_key(\"log_dist\"), coeffs)\n        params[\"contrast\"] = self.get_key(\"contrast\"), np.array(contrast)\n\n        return params\n\n    def model_interferogram(\n        self,\n        psf,\n        model,\n        rotate: bool = None,\n    ):\n\n        contrast = model.params[\"contrast\"][self.get_key(\"contrast\")]\n        psf1 = psf * (1 - contrast)\n        psf2 = psf * (contrast)\n\n        # convolve source with PSF\n        resolved_component = model.get_distribution(self, rotate=rotate)\n        return psf1 + psf2.convolve(resolved_component, method=\"fft\").data\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit","title":"<code>ResolvedOIFit</code>","text":"<p>               Bases: <code>_OIFit</code>, <code>_BaseResolvedFit</code></p> <p>OI-data backed resolved-source fit utilities.</p> <p>This class mixes the OI-data wrapper behaviour from :class:<code>_OIFit</code> with the resolved-source helpers in :class:<code>_BaseResolvedFit</code>. It provides methods to convert distributions into OTFs/visibilities, produce model DISCO outputs, and compute dirty images usable for visualisation and normalisation.</p> <p>Methods:</p> Name Description <code>initialise_params</code> <p>Prepare <code>log_dist</code> and <code>base_uv</code> parameters for an OI fit.</p> <code>to_otf</code> <p>Return a dLux MFT representing the distribution in OTF space.</p> <code>to_cvis</code> <p>Convert an image distribution into flattened complex visibilities suitable for DISCO-style modelling.</p> <code>dirty_image</code> <p>Compute a dirty image from the underlying observed OI visibilities.</p> <code>__call__</code> <p>Produce the amplitudes/phases used by DISCO from the model distribution.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class ResolvedOIFit(_OIFit, _BaseResolvedFit):\n    \"\"\"OI-data backed resolved-source fit utilities.\n\n    This class mixes the OI-data wrapper behaviour from :class:`_OIFit` with\n    the resolved-source helpers in :class:`_BaseResolvedFit`. It provides\n    methods to convert distributions into OTFs/visibilities, produce model\n    DISCO outputs, and compute dirty images usable for visualisation and\n    normalisation.\n\n    Methods\n    -------\n    initialise_params(model, distribution)\n        Prepare ``log_dist`` and ``base_uv`` parameters for an OI fit.\n    to_otf(model, distribution)\n        Return a dLux MFT representing the distribution in OTF space.\n    to_cvis(model, distribution)\n        Convert an image distribution into flattened complex visibilities\n        suitable for DISCO-style modelling.\n    dirty_image(...)\n        Compute a dirty image from the underlying observed OI visibilities.\n    __call__(model, rotate=None)\n        Produce the amplitudes/phases used by DISCO from the model\n        distribution.\n    \"\"\"\n\n    def initialise_params(self, model, distribution):\n\n        params = {}  # Initialise an empty dictionary for parameters\n        distribution /= distribution.sum()  # normalise the distribution\n\n        params[\"log_dist\"] = self.get_key(\"log_dist\"), np.log10(distribution)\n        params[\"base_uv\"] = self.get_key(\"base_uv\"), self.get_base_uv(model, distribution.shape[0])\n\n        return params\n\n    def get_key(self, param):\n\n        match param:\n            case \"log_dist\":\n                return self.filter\n            case \"base_uv\":\n                return self.filter  # this is probably unnecessary\n\n    def map_param(self, param):\n\n        # Map the appropriate parameter to the correct key\n        if param in [\"log_dist\", \"base_uv\"]:\n            return f\"{param}.{self.get_key(param)}\"\n\n        # Else its global\n        return param\n\n    def get_base_uv(self, model, n_pix):\n        \"\"\"\n        Get the base uv for normalisation\n\n        Args:\n            model: The model object containing the parameters.\n            n_pix: The number of pixels in one axis of the distribution.\n        Returns:\n            Array: The base UV for normalisation, which is the Fourier transform of a delta function.\n        \"\"\"\n        ind = n_pix // 2\n        base_dist = np.zeros((n_pix, n_pix)).at[ind, ind].set(1.0)\n\n        # base uv for normalisation\n        base_uv = self.to_otf(model, base_dist)\n        return base_uv\n\n    def to_otf(self, model, distribution):\n        \"\"\"\n        Transform the distribution to the OTF plane (Optical Transfer Function).\n        This method performs a Matrix Fourier Transform of the distribution and returns the\n        resulting visibilities in the OTF format.\n        Args:\n            model: The model object containing the parameters.\n            distribution: The distribution of the resolved source.\n        Returns:\n            dlu.MFT: The OTF visibilities as a dLux MFT object.\n        \"\"\"\n\n        return dlu.MFT(\n            phasor=distribution + 0j,\n            wavelength=self.wavel,\n            pixel_scale_in=model.pscale_in,\n            npixels_out=model.uv_npixels,\n            pixel_scale_out=model.uv_pscale,\n            inverse=True,\n        )\n\n    def to_cvis(self, model, distribution):\n        \"\"\"Convert an image distribution into complex visibilities for DISCO.\n\n        The pipeline performed here is:\n        1. Transform the image distribution to the OTF plane via\n           :meth:`to_otf` (a dLux MFT).\n        2. Normalise the complex u,v plane by the stored ``base_uv`` for this\n           fit (see :meth:`initialise_params`).\n        3. Downsample the u,v plane to the DISCO sampling using\n           :func:`dlu.downsample`.\n        4. Flatten the 2D u,v array and return the first half of the vector \u2014\n           for a real-valued image the Fourier transform is Hermitian symmetric\n           and only half the plane is needed.\n\n        Parameters\n        ----------\n        model : object\n            Model object providing UV/OTF parameters and access to\n            ``model.params['base_uv']`` for normalisation.\n        distribution : array-like\n            2D image array (npixels x npixels) describing the resolved source\n            brightness distribution.\n\n        Returns\n        -------\n        numpy.ndarray\n            1-D complex array containing the flattened (half) complex\n            visibilities suitable for DISCO-style modelling.\n\n        Notes\n        -----\n        The returned vector contains only the first half of the flattened\n        u,v array because of u/v symmetry; callers expecting a full u,v\n        representation should reconstruct it using Hermitian symmetry.\n        \"\"\"\n\n        # Perform MFT and move to OTF plane\n        uv = self.to_otf(model, distribution)  # shape (102, 102)\n\n        # Normalise the complex u,v plane\n        uv /= model.params[\"base_uv\"][self.get_key(\"base_uv\")]\n\n        # Downsample to the desired u,v resolution\n        uv = dlu.downsample(uv, 2, mean=True)  # shape (51, 51)\n\n        # flatten and take first half (u,v symmetry)\n        cvis = uv.flatten()[: uv.size // 2]\n\n        return cvis\n\n    def model_disco(self, model, distribution):\n        \"\"\"\n        Compute the model visibilities and phases for the given model object.\n        \"\"\"\n        cvis = self.to_cvis(model, distribution)\n        return self.flatten_model(cvis)\n\n    def dirty_image(\n        self, model, npix=None, rotate=True, otf_support=None, pad=None, pad_value=1 + 0j\n    ):\n        \"\"\"\n        Get the dirty image via MFT. This is the image that would be obtained\n        if the visibilities were directly transformed back to the image plane.\n\n        Args:\n            model: The model object containing the parameters.\n            npix: The number of pixels in one axis of the dirty image.\n                    If None, uses the same size as the model source distribution.\n            rotate: If True, rotates the dirty image by the parallactic angle.\n                    If a float, rotates by that (-'ve) angle in radians.\n        Returns:\n            Array: The dirty image, normalised to sum to 1.\n        \"\"\"\n\n        if npix is None:\n            npix = model.get_distribution(self).shape[0]\n\n        # converting to u,v visibilities\n        log_vis = np.dot(np.linalg.pinv(self.vis_mat), self.vis)\n        phase = np.dot(np.linalg.pinv(self.phi_mat), self.phi)\n        vis_im, phase_im = vis_to_im(log_vis, phase, (51, 51))\n\n        # exponentiating\n        uv = np.exp(vis_im + 1j * phase_im)\n\n        if pad is not None:\n            # Pad the uv visibilities if a pad is specified\n            uv = np.pad(uv, pad_width=pad, mode=\"constant\", constant_values=pad_value)\n\n        # If an OTF support is provided, apply it to the uv visibilities\n        if otf_support is not None:\n            uv *= otf_support\n\n        # Getting the dirty image\n        dirty_image = dlu.MFT(\n            phasor=uv,\n            wavelength=self.wavel,\n            pixel_scale_in=2 * model.uv_pscale,\n            npixels_out=npix,\n            pixel_scale_out=model.pscale_in,\n            inverse=True,\n        )\n\n        # Taking amplitudes\n        dirty_image = np.abs(dirty_image)\n\n        # Optional rotation of the dirty image\n        if rotate:\n            dirty_image = self.rotate(dirty_image)\n\n        # Normalise the image\n        return dirty_image / dirty_image.sum()\n\n    def __call__(self, model, rotate: bool = None):\n        \"\"\"\n        Simulate the DISCOs from the resolved source distribution.\n        This method retrieves the distribution from the model, optionally rotates it,\n        and then computes the DISCOs using the model_disco method.\n        Args:\n            model: The model object containing the parameters.\n            rotate: If True, rotates the distribution by the parallactic angle.\n                    If a float, rotates by that (-'ve) angle in radians.\n        Returns:\n            tuple: A tuple containing the amplitudes and phases in the DISCO basis.\n        \"\"\"\n        # NOTE: Distribution must be odd number of pixels in one axis\n        distribution = model.get_distribution(self, rotate=rotate)\n\n        return self.model_disco(model, distribution=distribution)\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit.get_base_uv","title":"<code>get_base_uv(model, n_pix)</code>","text":"<p>Get the base uv for normalisation</p> <p>Args:     model: The model object containing the parameters.     n_pix: The number of pixels in one axis of the distribution. Returns:     Array: The base UV for normalisation, which is the Fourier transform of a delta function.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def get_base_uv(self, model, n_pix):\n    \"\"\"\n    Get the base uv for normalisation\n\n    Args:\n        model: The model object containing the parameters.\n        n_pix: The number of pixels in one axis of the distribution.\n    Returns:\n        Array: The base UV for normalisation, which is the Fourier transform of a delta function.\n    \"\"\"\n    ind = n_pix // 2\n    base_dist = np.zeros((n_pix, n_pix)).at[ind, ind].set(1.0)\n\n    # base uv for normalisation\n    base_uv = self.to_otf(model, base_dist)\n    return base_uv\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit.to_otf","title":"<code>to_otf(model, distribution)</code>","text":"<p>Transform the distribution to the OTF plane (Optical Transfer Function). This method performs a Matrix Fourier Transform of the distribution and returns the resulting visibilities in the OTF format. Args:     model: The model object containing the parameters.     distribution: The distribution of the resolved source. Returns:     dlu.MFT: The OTF visibilities as a dLux MFT object.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def to_otf(self, model, distribution):\n    \"\"\"\n    Transform the distribution to the OTF plane (Optical Transfer Function).\n    This method performs a Matrix Fourier Transform of the distribution and returns the\n    resulting visibilities in the OTF format.\n    Args:\n        model: The model object containing the parameters.\n        distribution: The distribution of the resolved source.\n    Returns:\n        dlu.MFT: The OTF visibilities as a dLux MFT object.\n    \"\"\"\n\n    return dlu.MFT(\n        phasor=distribution + 0j,\n        wavelength=self.wavel,\n        pixel_scale_in=model.pscale_in,\n        npixels_out=model.uv_npixels,\n        pixel_scale_out=model.uv_pscale,\n        inverse=True,\n    )\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit.to_cvis","title":"<code>to_cvis(model, distribution)</code>","text":"<p>Convert an image distribution into complex visibilities for DISCO.</p> <p>The pipeline performed here is: 1. Transform the image distribution to the OTF plane via    :meth:<code>to_otf</code> (a dLux MFT). 2. Normalise the complex u,v plane by the stored <code>base_uv</code> for this    fit (see :meth:<code>initialise_params</code>). 3. Downsample the u,v plane to the DISCO sampling using    :func:<code>dlu.downsample</code>. 4. Flatten the 2D u,v array and return the first half of the vector \u2014    for a real-valued image the Fourier transform is Hermitian symmetric    and only half the plane is needed.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>Model object providing UV/OTF parameters and access to <code>model.params['base_uv']</code> for normalisation.</p> required <code>distribution</code> <code>array - like</code> <p>2D image array (npixels x npixels) describing the resolved source brightness distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>1-D complex array containing the flattened (half) complex visibilities suitable for DISCO-style modelling.</p> Notes <p>The returned vector contains only the first half of the flattened u,v array because of u/v symmetry; callers expecting a full u,v representation should reconstruct it using Hermitian symmetry.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def to_cvis(self, model, distribution):\n    \"\"\"Convert an image distribution into complex visibilities for DISCO.\n\n    The pipeline performed here is:\n    1. Transform the image distribution to the OTF plane via\n       :meth:`to_otf` (a dLux MFT).\n    2. Normalise the complex u,v plane by the stored ``base_uv`` for this\n       fit (see :meth:`initialise_params`).\n    3. Downsample the u,v plane to the DISCO sampling using\n       :func:`dlu.downsample`.\n    4. Flatten the 2D u,v array and return the first half of the vector \u2014\n       for a real-valued image the Fourier transform is Hermitian symmetric\n       and only half the plane is needed.\n\n    Parameters\n    ----------\n    model : object\n        Model object providing UV/OTF parameters and access to\n        ``model.params['base_uv']`` for normalisation.\n    distribution : array-like\n        2D image array (npixels x npixels) describing the resolved source\n        brightness distribution.\n\n    Returns\n    -------\n    numpy.ndarray\n        1-D complex array containing the flattened (half) complex\n        visibilities suitable for DISCO-style modelling.\n\n    Notes\n    -----\n    The returned vector contains only the first half of the flattened\n    u,v array because of u/v symmetry; callers expecting a full u,v\n    representation should reconstruct it using Hermitian symmetry.\n    \"\"\"\n\n    # Perform MFT and move to OTF plane\n    uv = self.to_otf(model, distribution)  # shape (102, 102)\n\n    # Normalise the complex u,v plane\n    uv /= model.params[\"base_uv\"][self.get_key(\"base_uv\")]\n\n    # Downsample to the desired u,v resolution\n    uv = dlu.downsample(uv, 2, mean=True)  # shape (51, 51)\n\n    # flatten and take first half (u,v symmetry)\n    cvis = uv.flatten()[: uv.size // 2]\n\n    return cvis\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit.model_disco","title":"<code>model_disco(model, distribution)</code>","text":"<p>Compute the model visibilities and phases for the given model object.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def model_disco(self, model, distribution):\n    \"\"\"\n    Compute the model visibilities and phases for the given model object.\n    \"\"\"\n    cvis = self.to_cvis(model, distribution)\n    return self.flatten_model(cvis)\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit.dirty_image","title":"<code>dirty_image(model, npix=None, rotate=True, otf_support=None, pad=None, pad_value=1 + 0j)</code>","text":"<p>Get the dirty image via MFT. This is the image that would be obtained if the visibilities were directly transformed back to the image plane.</p> <p>Args:     model: The model object containing the parameters.     npix: The number of pixels in one axis of the dirty image.             If None, uses the same size as the model source distribution.     rotate: If True, rotates the dirty image by the parallactic angle.             If a float, rotates by that (-'ve) angle in radians. Returns:     Array: The dirty image, normalised to sum to 1.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def dirty_image(\n    self, model, npix=None, rotate=True, otf_support=None, pad=None, pad_value=1 + 0j\n):\n    \"\"\"\n    Get the dirty image via MFT. This is the image that would be obtained\n    if the visibilities were directly transformed back to the image plane.\n\n    Args:\n        model: The model object containing the parameters.\n        npix: The number of pixels in one axis of the dirty image.\n                If None, uses the same size as the model source distribution.\n        rotate: If True, rotates the dirty image by the parallactic angle.\n                If a float, rotates by that (-'ve) angle in radians.\n    Returns:\n        Array: The dirty image, normalised to sum to 1.\n    \"\"\"\n\n    if npix is None:\n        npix = model.get_distribution(self).shape[0]\n\n    # converting to u,v visibilities\n    log_vis = np.dot(np.linalg.pinv(self.vis_mat), self.vis)\n    phase = np.dot(np.linalg.pinv(self.phi_mat), self.phi)\n    vis_im, phase_im = vis_to_im(log_vis, phase, (51, 51))\n\n    # exponentiating\n    uv = np.exp(vis_im + 1j * phase_im)\n\n    if pad is not None:\n        # Pad the uv visibilities if a pad is specified\n        uv = np.pad(uv, pad_width=pad, mode=\"constant\", constant_values=pad_value)\n\n    # If an OTF support is provided, apply it to the uv visibilities\n    if otf_support is not None:\n        uv *= otf_support\n\n    # Getting the dirty image\n    dirty_image = dlu.MFT(\n        phasor=uv,\n        wavelength=self.wavel,\n        pixel_scale_in=2 * model.uv_pscale,\n        npixels_out=npix,\n        pixel_scale_out=model.pscale_in,\n        inverse=True,\n    )\n\n    # Taking amplitudes\n    dirty_image = np.abs(dirty_image)\n\n    # Optional rotation of the dirty image\n    if rotate:\n        dirty_image = self.rotate(dirty_image)\n\n    # Normalise the image\n    return dirty_image / dirty_image.sum()\n</code></pre>"},{"location":"docs/api/#dorito.model_fits.ResolvedOIFit.__call__","title":"<code>__call__(model, rotate=None)</code>","text":"<p>Simulate the DISCOs from the resolved source distribution. This method retrieves the distribution from the model, optionally rotates it, and then computes the DISCOs using the model_disco method. Args:     model: The model object containing the parameters.     rotate: If True, rotates the distribution by the parallactic angle.             If a float, rotates by that (-'ve) angle in radians. Returns:     tuple: A tuple containing the amplitudes and phases in the DISCO basis.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def __call__(self, model, rotate: bool = None):\n    \"\"\"\n    Simulate the DISCOs from the resolved source distribution.\n    This method retrieves the distribution from the model, optionally rotates it,\n    and then computes the DISCOs using the model_disco method.\n    Args:\n        model: The model object containing the parameters.\n        rotate: If True, rotates the distribution by the parallactic angle.\n                If a float, rotates by that (-'ve) angle in radians.\n    Returns:\n        tuple: A tuple containing the amplitudes and phases in the DISCO basis.\n    \"\"\"\n    # NOTE: Distribution must be odd number of pixels in one axis\n    distribution = model.get_distribution(self, rotate=rotate)\n\n    return self.model_disco(model, distribution=distribution)\n</code></pre>"},{"location":"docs/api/#models","title":"Models","text":"<p>Models and Amigo model subclasses used for resolved sources.</p> <p>This module implements resolved-source models for both image plane fitting and interferometric data (DISCO).</p>"},{"location":"docs/api/#dorito.models.ResolvedAmigoModel","title":"<code>ResolvedAmigoModel</code>","text":"<p>               Bases: <code>_AmigoModel</code>, <code>_BaseResolvedModel</code></p> <p>Amigo model specialised for resolved (image-plane) sources.</p> <p>This class composes the internal <code>_AmigoModel</code> parameter initialisation behaviour with the <code>_BaseResolvedModel</code> helpers for retrieving a resolved-source distribution. It is the primary model used in the examples to represent a resolved astronomical source for use with the amigo fitting machinery.</p> <p>Parameters:</p> Name Type Description Default <code>exposures</code> <code>sequence</code> <p>Sequence of exposure / fit objects describing each observation.</p> required <code>optics</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>detector</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>ramp_model</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>read</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>state</code> <code>mapping</code> <p>Optional calibration state used to override optics/detector/ramp initial values.</p> required <code>rotate</code> <code>bool</code> <p>If True (default) apply exposure rotation to distributions.</p> <code>True</code> <code>source_oversample</code> <code>int</code> <p>Oversampling factor for source-plane operations. When setting an oversampling factor &gt; 1, the optics model must be initialised with an oversample to match (e.g. 3 times source_oversample).</p> <code>1</code> <code>param_initers</code> <code>dict</code> <p>Parameter initialiser values forwarded to exposure initialisation.</p> <code>None</code> Source code in <code>src/dorito/models.py</code> <pre><code>class ResolvedAmigoModel(_AmigoModel, _BaseResolvedModel):\n    \"\"\"Amigo model specialised for resolved (image-plane) sources.\n\n    This class composes the internal `_AmigoModel` parameter initialisation\n    behaviour with the `_BaseResolvedModel` helpers for retrieving a\n    resolved-source distribution. It is the primary model used in the\n    examples to represent a resolved astronomical source for use with the\n    amigo fitting machinery.\n\n    Parameters\n    ----------\n    exposures : sequence\n        Sequence of exposure / fit objects describing each observation.\n    optics, detector, ramp_model, read\n        Amigo-style objects used to build the forward model (see amigo\n        documentation for expected types).\n    state : mapping, optional\n        Optional calibration state used to override optics/detector/ramp\n        initial values.\n    rotate : bool, optional\n        If True (default) apply exposure rotation to distributions.\n    source_oversample : int, optional\n        Oversampling factor for source-plane operations. When setting an\n        oversampling factor &gt; 1, the optics model must be initialised\n        with an oversample to match (e.g. 3 times source_oversample).\n    param_initers : dict, optional\n        Parameter initialiser values forwarded to exposure initialisation.\n    \"\"\"\n\n    source_oversample: int = 1\n\n    def __init__(\n        self,\n        exposures,\n        optics,\n        detector,\n        ramp_model,\n        read,\n        state,\n        rotate: bool = True,\n        source_oversample=1,\n        param_initers: dict = None,\n    ):\n        self.rotate = rotate\n        self.source_oversample = source_oversample\n\n        super().__init__(exposures, optics, detector, ramp_model, read, state, param_initers)\n</code></pre>"},{"location":"docs/api/#dorito.models.TransformedResolvedModel","title":"<code>TransformedResolvedModel</code>","text":"<p>               Bases: <code>ResolvedAmigoModel</code></p> <p>Resolved model that stores and operates in a compact image basis.</p> <p>This class wraps a provided <code>ImageBasis</code> object and stores the source distribution as basis coefficients. When initialising, if a <code>distribution</code> is provided in <code>param_initers</code> it is converted to basis coefficients and stored under the <code>coeffs</code> initialiser key.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>ImageBasis</code> <p>Basis object providing <code>to_basis</code> / <code>from_basis</code> conversions.</p> required <code>window</code> <code>Array</code> <p>Optional multiplicative window applied to reconstructed images.</p> <code>None</code> <code>source_oversample</code> <code>int</code> <p>Oversampling factor for source-plane operations.</p> <code>1</code> <code>param_initers</code> <code>dict</code> <p>Parameter initialisers; accepts a <code>distribution</code> entry which will be converted to <code>coeffs</code> via the supplied <code>basis</code>.</p> <code>{}</code> Source code in <code>src/dorito/models.py</code> <pre><code>class TransformedResolvedModel(ResolvedAmigoModel):\n    \"\"\"Resolved model that stores and operates in a compact image basis.\n\n    This class wraps a provided ``ImageBasis`` object and stores the\n    source distribution as basis coefficients. When initialising, if a\n    ``distribution`` is provided in ``param_initers`` it is converted to\n    basis coefficients and stored under the ``coeffs`` initialiser key.\n\n    Parameters\n    ----------\n    basis : ImageBasis\n        Basis object providing ``to_basis`` / ``from_basis`` conversions.\n    window : Array, optional\n        Optional multiplicative window applied to reconstructed images.\n    source_oversample : int, optional\n        Oversampling factor for source-plane operations.\n    param_initers : dict, optional\n        Parameter initialisers; accepts a ``distribution`` entry which will\n        be converted to ``coeffs`` via the supplied ``basis``.\n    \"\"\"\n\n    basis: None\n    window: Array\n\n    def __init__(\n        self,\n        exposures,\n        optics,\n        detector,\n        ramp_model,\n        read,\n        basis: ImageBasis,\n        state,\n        source_oversample=1,\n        window: Array = None,\n        param_initers: dict = {},\n        rotate: bool = True,\n    ):\n\n        # This seems to fix some recompile issues\n        def fn(x):\n            if isinstance(x, Array):\n                if \"i\" in x.dtype.str:\n                    return x\n                return np.array(x, dtype=float)\n            return x\n\n        self.basis = jtu.map(lambda x: fn(x), basis)\n        self.window = window\n\n        if \"distribution\" in param_initers.keys():\n            init_log_dist = np.log10(param_initers[\"distribution\"])\n            init_coeffs = self.basis.to_basis(init_log_dist)\n            param_initers[\"coeffs\"] = init_coeffs\n            del param_initers[\"distribution\"]\n\n        super().__init__(\n            exposures,\n            optics,\n            detector,\n            ramp_model,\n            read,\n            state,\n            rotate,\n            source_oversample,\n            param_initers,\n        )\n\n    def get_distribution(\n        self,\n        exposure,\n        rotate: bool = None,\n        exponentiate=True,\n        window=True,\n    ):\n\n        coeffs = self.params[\"log_dist\"][exposure.get_key(\"log_dist\")]\n\n        # exponentiation\n        if exponentiate:\n            distribution = 10 ** self.basis.from_basis(coeffs)\n        else:\n            distribution = self.basis.from_basis(coeffs)\n\n        # windowing\n        if self.window is not None and window:\n            distribution *= self.window\n\n        # rotation\n        if rotate is None:\n            rotate = self.rotate\n        if rotate:\n            distribution = exposure.rotate(distribution)\n\n        return distribution\n</code></pre>"},{"location":"docs/api/#dorito.models.ResolvedDiscoModel","title":"<code>ResolvedDiscoModel</code>","text":"<p>               Bases: <code>_BaseResolvedModel</code></p> <p>Resolved-source model container for DISCO / interferometric fits.</p> <p>This lightweight container holds parameters required to transform an image-plane distribution into the complex visibilities used by the DISCO-style fitting code. The constructor collects per-oi parameters by calling each <code>oi.initialise_params(self, distribution)</code> and assembling a parameter mapping compatible with the rest of the amigo pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>ois</code> <code>list</code> <p>List of OI-like exposure objects providing <code>initialise_params</code> and other data accessors used during fitting.</p> required <code>distribution</code> <code>Array</code> <p>Initial image-plane distribution used to derive initial parameters.</p> required <code>uv_npixels</code> <code>int</code> <p>Number of pixels in the output u/v plane used for transforms.</p> required <code>uv_pscale</code> <code>float</code> <p>Pixel scale in the u/v plane.</p> required <code>oversample</code> <code>float</code> <p>Image-plane oversampling factor used by the model (default: 1.0).</p> <code>1.0</code> <code>psf_pixel_scale</code> <code>float</code> <p>PSF pixel scale in arcseconds per pixel (default chosen for examples).</p> <code>0.065524085</code> <code>rotate</code> <code>bool</code> <p>If True, model-dirty images and transforms will be rotated by the exposure parallactic angle when requested.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>pscale_in</code> <code>float</code> <p>Property returning the image-plane pixel scale in radians per pixel.</p> Source code in <code>src/dorito/models.py</code> <pre><code>class ResolvedDiscoModel(_BaseResolvedModel):\n    \"\"\"Resolved-source model container for DISCO / interferometric fits.\n\n    This lightweight container holds parameters required to transform an\n    image-plane distribution into the complex visibilities used by the\n    DISCO-style fitting code. The constructor collects per-oi parameters by\n    calling each `oi.initialise_params(self, distribution)` and assembling a\n    parameter mapping compatible with the rest of the amigo pipeline.\n\n    Parameters\n    ----------\n    ois : list\n        List of OI-like exposure objects providing `initialise_params` and\n        other data accessors used during fitting.\n    distribution : Array\n        Initial image-plane distribution used to derive initial parameters.\n    uv_npixels : int\n        Number of pixels in the output u/v plane used for transforms.\n    uv_pscale : float\n        Pixel scale in the u/v plane.\n    oversample : float, optional\n        Image-plane oversampling factor used by the model (default: 1.0).\n    psf_pixel_scale : float, optional\n        PSF pixel scale in arcseconds per pixel (default chosen for examples).\n    rotate : bool, optional\n        If True, model-dirty images and transforms will be rotated by the\n        exposure parallactic angle when requested.\n\n    Attributes\n    ----------\n    pscale_in : float\n        Property returning the image-plane pixel scale in radians per pixel.\n    \"\"\"\n\n    uv_npixels: int\n    uv_pscale: float\n    oversample: float\n    psf_pixel_scale: float\n\n    def __init__(\n        self,\n        ois: list,\n        distribution: Array,\n        uv_npixels: int,\n        uv_pscale: float,\n        oversample: float = 1.0,\n        psf_pixel_scale: float = 0.065524085,  # arcsec/pixel\n        rotate: bool = True,\n    ):\n\n        self.uv_npixels = uv_npixels\n        self.oversample = oversample\n        self.uv_pscale = uv_pscale\n        self.psf_pixel_scale = psf_pixel_scale\n        self.rotate = rotate\n\n        params = {}\n        for oi in ois:\n            param_dict = oi.initialise_params(self, distribution)\n            for param, (key, value) in param_dict.items():\n                if param not in params.keys():\n                    params[param] = {}\n                params[param][key] = value\n\n        super().__init__(params)\n\n    @property\n    def pscale_in(self):\n        \"\"\"\n        The pixel scale of the image plane, in radians per pixel.\n        \"\"\"\n        return dlu.arcsec2rad(self.psf_pixel_scale / self.oversample)\n</code></pre>"},{"location":"docs/api/#dorito.models.ResolvedDiscoModel.pscale_in","title":"<code>pscale_in</code>  <code>property</code>","text":"<p>The pixel scale of the image plane, in radians per pixel.</p>"},{"location":"docs/api/#bases","title":"Bases","text":""},{"location":"docs/api/#dorito.bases.ImageBasis","title":"<code>ImageBasis</code>","text":"<p>               Bases: <code>Base</code></p> <p>Linear image basis wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>transform_matrix</code> <code>Array</code> <p>Matrix that maps basis coefficients to flattened image pixels. The class stores the forward matrix <code>M</code> and a pseudo-inverse <code>M_inv</code> used to move between pixel and basis representations.</p> required Notes <p>The class intentionally accepts non-orthogonal bases and computes the pseudo-inverse when <code>ortho=False</code>.</p> Source code in <code>src/dorito/bases.py</code> <pre><code>class ImageBasis(Base):\n    \"\"\"Linear image basis wrapper.\n\n    Parameters\n    ----------\n    transform_matrix\n        Matrix that maps basis coefficients to flattened image pixels. The\n        class stores the forward matrix `M` and a pseudo-inverse `M_inv` used\n        to move between pixel and basis representations.\n\n    Notes\n    -----\n    The class intentionally accepts non-orthogonal bases and computes the\n    pseudo-inverse when `ortho=False`.\n    \"\"\"\n\n    M: Array\n    M_inv: Array\n    n_basis: int = eqx.field(static=True)\n    size: int = eqx.field(static=True)\n\n    def __init__(self, transform_matrix: Array, n_basis: int = None, ortho=False):\n        if n_basis is None:\n            n_basis = transform_matrix.shape[1]\n        self.n_basis = n_basis\n        self.M = transform_matrix[:, :n_basis]\n        if ortho:\n            self.M_inv = self.M.T\n        else:\n            self.M_inv = np.linalg.pinv(self.M)\n        self.size = int(np.sqrt(self.M.shape[0]))\n\n    def to_basis(self, img: Array) -&gt; Array:\n        \"\"\"Project a 2D image into the basis and return coefficients.\n\n        Parameters\n        ----------\n        img : Array\n            2D image array with shape (size, size).\n\n        Returns\n        -------\n        Array\n            Basis coefficients (flattened).\n        \"\"\"\n        return np.dot(self.M_inv, img.flatten())\n\n    def from_basis(self, coeffs: Array) -&gt; Array:\n        \"\"\"Reconstruct an image from basis coefficients.\n\n        Parameters\n        ----------\n        coeffs : Array\n            Basis coefficients.\n\n        Returns\n        -------\n        Array\n            2D image reconstructed from the provided coefficients.\n        \"\"\"\n        return np.dot(self.M, coeffs).reshape((self.size, self.size))\n</code></pre>"},{"location":"docs/api/#dorito.bases.ImageBasis.to_basis","title":"<code>to_basis(img)</code>","text":"<p>Project a 2D image into the basis and return coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>Array</code> <p>2D image array with shape (size, size).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Basis coefficients (flattened).</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def to_basis(self, img: Array) -&gt; Array:\n    \"\"\"Project a 2D image into the basis and return coefficients.\n\n    Parameters\n    ----------\n    img : Array\n        2D image array with shape (size, size).\n\n    Returns\n    -------\n    Array\n        Basis coefficients (flattened).\n    \"\"\"\n    return np.dot(self.M_inv, img.flatten())\n</code></pre>"},{"location":"docs/api/#dorito.bases.ImageBasis.from_basis","title":"<code>from_basis(coeffs)</code>","text":"<p>Reconstruct an image from basis coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>Array</code> <p>Basis coefficients.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>2D image reconstructed from the provided coefficients.</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def from_basis(self, coeffs: Array) -&gt; Array:\n    \"\"\"Reconstruct an image from basis coefficients.\n\n    Parameters\n    ----------\n    coeffs : Array\n        Basis coefficients.\n\n    Returns\n    -------\n    Array\n        2D image reconstructed from the provided coefficients.\n    \"\"\"\n    return np.dot(self.M, coeffs).reshape((self.size, self.size))\n</code></pre>"},{"location":"docs/api/#dorito.bases.inscribed_circ_basis","title":"<code>inscribed_circ_basis(size, return_window=True)</code>","text":"<p>Create an image basis using pixels inside an inscribed circular window.</p> <p>The function builds a linear basis matrix <code>M</code> that maps basis coefficients to the flattened image pixels for the pixels that lie inside a circular top-hat window inscribed in a square of side <code>size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of pixels on a side of the (square) image. The function constructs a <code>size x size</code> window and selects pixels inside the inscribed top-hat.</p> required <code>return_window</code> <code>bool</code> <p>If True (default) return a tuple <code>(ImageBasis, window_arr)</code> where <code>window_arr</code> is the boolean mask of selected pixels. Otherwise return only the <code>ImageBasis</code> instance.</p> <code>True</code> <p>Returns:</p> Type Description <code>ImageBasis or (ImageBasis, ndarray)</code> <p>The basis mapping (and optionally the boolean window mask).</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def inscribed_circ_basis(size: int, return_window=True) -&gt; Array:\n    \"\"\"Create an image basis using pixels inside an inscribed circular window.\n\n    The function builds a linear basis matrix `M` that maps basis\n    coefficients to the flattened image pixels for the pixels that lie\n    inside a circular top-hat window inscribed in a square of side ``size``.\n\n    Parameters\n    ----------\n    size : int\n        Number of pixels on a side of the (square) image. The function\n        constructs a ``size x size`` window and selects pixels inside the\n        inscribed top-hat.\n    return_window : bool, optional\n        If True (default) return a tuple ``(ImageBasis, window_arr)`` where\n        ``window_arr`` is the boolean mask of selected pixels. Otherwise\n        return only the ``ImageBasis`` instance.\n\n    Returns\n    -------\n    ImageBasis or (ImageBasis, ndarray)\n        The basis mapping (and optionally the boolean window mask).\n    \"\"\"\n\n    window_arr = TopHatWindow(1)((size, size))\n    mask = onp.where(window_arr.flatten())[0]\n    M = onp.eye(size**2)[:, mask]\n    if return_window:\n        return ImageBasis(np.array(M), ortho=True), window_arr\n    return ImageBasis(np.array(M))\n</code></pre>"},{"location":"docs/api/#dorito.bases.inscribed_annulus_basis","title":"<code>inscribed_annulus_basis(size, iterations=2, return_window=True)</code>","text":"<p>Create an image basis for an annulus (inscribed ring) window.</p> <p>Constructs a basis matrix selecting pixels that lie in an annulus defined by subtracting an inner dilated mask from an outer top-hat window. The inner radius is controlled by <code>iterations</code> passed to <code>scipy.ndimage.binary_dilation</code> so larger <code>iterations</code> produce a wider inner hole.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of pixels on a side of the (square) image.</p> required <code>iterations</code> <code>int</code> <p>Number of binary dilation iterations used to build the inner hole (default: 2).</p> <code>2</code> <code>return_window</code> <code>bool</code> <p>If True (default) return a tuple <code>(ImageBasis, window_arr)</code> where <code>window_arr</code> is the boolean mask of selected annulus pixels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ImageBasis or (ImageBasis, ndarray)</code> <p>The basis mapping (and optionally the boolean window mask).</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def inscribed_annulus_basis(size: int, iterations=2, return_window=True) -&gt; Array:\n    \"\"\"Create an image basis for an annulus (inscribed ring) window.\n\n    Constructs a basis matrix selecting pixels that lie in an annulus\n    defined by subtracting an inner dilated mask from an outer top-hat\n    window. The inner radius is controlled by ``iterations`` passed to\n    ``scipy.ndimage.binary_dilation`` so larger ``iterations`` produce a\n    wider inner hole.\n\n    Parameters\n    ----------\n    size : int\n        Number of pixels on a side of the (square) image.\n    iterations : int, optional\n        Number of binary dilation iterations used to build the inner hole\n        (default: 2).\n    return_window : bool, optional\n        If True (default) return a tuple ``(ImageBasis, window_arr)`` where\n        ``window_arr`` is the boolean mask of selected annulus pixels.\n\n    Returns\n    -------\n    ImageBasis or (ImageBasis, ndarray)\n        The basis mapping (and optionally the boolean window mask).\n    \"\"\"\n\n    outer = TopHatWindow(1)((size, size))\n    inner = binary_dilation(\n        np.zeros_like(outer).at[size // 2, size // 2].set(1), iterations=iterations\n    )\n    window_arr = outer - inner\n\n    mask = onp.where(window_arr.flatten())[0]\n    M = onp.eye(size**2)[:, mask]\n    if return_window:\n        return ImageBasis(np.array(M), ortho=True), window_arr\n    return ImageBasis(np.array(M))\n</code></pre>"},{"location":"docs/api/#stats","title":"Stats","text":"<p>Statistical loss functions and regularisers used in model fitting.</p> <p>This module collects likelihood wrappers and a set of regulariser loss functions (TV, TSV, L1, L2, Maximum Entropy) used across the fitting utilities. Regularisation functions of the for \"REG_loss\" accept raw arrays, and those of the form \"REG\" accept the common <code>model, exposure</code> pair used by <code>amigo</code>.</p>"},{"location":"docs/api/#dorito.stats.L1_loss","title":"<code>L1_loss(arr)</code>","text":"<p>L1 norm loss for array-like inputs.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def L1_loss(arr):\n    \"\"\"L1 norm loss for array-like inputs.\"\"\"\n    return np.nansum(np.abs(arr))\n</code></pre>"},{"location":"docs/api/#dorito.stats.L2_loss","title":"<code>L2_loss(arr)</code>","text":"<p>L2 (quadratic) loss for array-like inputs.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def L2_loss(arr):\n    \"\"\"L2 (quadratic) loss for array-like inputs.\"\"\"\n    return np.nansum(arr**2)\n</code></pre>"},{"location":"docs/api/#dorito.stats.tikhinov","title":"<code>tikhinov(arr)</code>","text":"<p>Finite-difference approximation used by several regularisers.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def tikhinov(arr):\n    \"\"\"Finite-difference approximation used by several regularisers.\"\"\"\n    pad_arr = np.pad(arr, 2)  # padding\n    dx = np.diff(pad_arr[0:-1, :], axis=1)\n    dy = np.diff(pad_arr[:, 0:-1], axis=0)\n    return dx**2 + dy**2\n</code></pre>"},{"location":"docs/api/#dorito.stats.TV_loss","title":"<code>TV_loss(arr, eps=1e-16)</code>","text":"<p>Total variation (approx.) loss computed from finite differences.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def TV_loss(arr, eps=1e-16):\n    \"\"\"Total variation (approx.) loss computed from finite differences.\"\"\"\n    return np.sqrt(tikhinov(arr) + eps**2).sum()\n</code></pre>"},{"location":"docs/api/#dorito.stats.TSV_loss","title":"<code>TSV_loss(arr)</code>","text":"<p>Total squared variation (quadratic) loss.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def TSV_loss(arr):\n    \"\"\"Total squared variation (quadratic) loss.\"\"\"\n    return tikhinov(arr).sum()\n</code></pre>"},{"location":"docs/api/#dorito.stats.ME_loss","title":"<code>ME_loss(arr, eps=1e-16)</code>","text":"<p>Maximum-entropy inspired loss (negative entropy of distribution).</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ME_loss(arr, eps=1e-16):\n    \"\"\"Maximum-entropy inspired loss (negative entropy of distribution).\"\"\"\n    P = arr / np.nansum(arr)\n    S = np.nansum(-P * np.log(P + eps))\n    return -S\n</code></pre>"},{"location":"docs/api/#dorito.stats.ramp_regularised_loss_fn","title":"<code>ramp_regularised_loss_fn(model, exp, args={'reg_dict': {}})</code>","text":"<p>Compute a regularised negative-log-likelihood for ramp data.</p> <p>Returns the scalar loss for a single exposure and a placeholder tuple (kept for amigo API compatibility).</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ramp_regularised_loss_fn(model, exp, args={\"reg_dict\": {}}):\n    \"\"\"Compute a regularised negative-log-likelihood for ramp data.\n\n    Returns the scalar loss for a single exposure and a placeholder tuple\n    (kept for amigo API compatibility).\n    \"\"\"\n\n    # regular likelihood term\n    likelihood = -np.nanmean(exp.mv_zscore(model))\n    prior = apply_regularisers(model, exp, args) if not exp.calibrator else 0.0\n\n    return likelihood + prior, ()\n</code></pre>"},{"location":"docs/api/#dorito.stats.apply_regularisers","title":"<code>apply_regularisers(model, exposure, args)</code>","text":"<p>Apply registered regularisers stored in <code>args['reg_dict']</code>.</p> <p>The expected format of <code>args['reg_dict']</code> is a mapping to pairs <code>(coeff, fun)</code> where <code>fun(model, exposure)</code> returns a scalar regulariser value.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def apply_regularisers(model, exposure, args):\n    \"\"\"Apply registered regularisers stored in ``args['reg_dict']``.\n\n    The expected format of ``args['reg_dict']`` is a mapping to pairs\n    ``(coeff, fun)`` where ``fun(model, exposure)`` returns a scalar regulariser\n    value.\n    \"\"\"\n\n    if \"reg_dict\" not in args.keys():\n        return 0.0\n\n    # evaluating the regularisation term with each for each regulariser\n    priors = [coeff * fun(model, exposure) for coeff, fun in args[\"reg_dict\"].values()]\n\n    # summing the different regularisers\n    return np.array(priors).sum()\n</code></pre>"},{"location":"docs/api/#dorito.stats.ramp_posterior_balance","title":"<code>ramp_posterior_balance(model, exp, args={'reg_dict': {}})</code>","text":"<p>Return likelihood and prior separately for an exposure.</p> <p>This is useful for diagnostics and for balancing regularisation strengths (e.g. L-curve construction).</p> <p>Note</p> <p>This may not work for multiple simultaneous regularisers.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ramp_posterior_balance(model, exp, args={\"reg_dict\": {}}):\n    \"\"\"Return likelihood and prior separately for an exposure.\n\n    This is useful for diagnostics and for balancing regularisation strengths\n    (e.g. L-curve construction).\n\n    !!! danger \"Note\"\n        This may not work for multiple simultaneous regularisers.\n    \"\"\"\n\n    # regular likelihood term\n    likelihood = -np.nanmean(exp.mv_zscore(model))\n\n    # evaluating the regularisation term with each for each regulariser\n    priors = [fun(model, exp) for _, fun in args[\"reg_dict\"].values()]\n    prior = np.array(priors).sum()\n\n    return likelihood, prior\n</code></pre>"},{"location":"docs/api/#dorito.stats.ramp_posterior_balances","title":"<code>ramp_posterior_balances(model, exposures, args={'reg_dict': {}})</code>","text":"<p>Compute likelihood/prior balances for a collection of exposures.</p> <p>Returns a dict with arrays of likelihoods and priors and the exposure keys for convenience in diagnostics.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ramp_posterior_balances(model, exposures, args={\"reg_dict\": {}}):\n    \"\"\"Compute likelihood/prior balances for a collection of exposures.\n\n    Returns a dict with arrays of likelihoods and priors and the exposure\n    keys for convenience in diagnostics.\n    \"\"\"\n\n    balances = np.array([ramp_posterior_balance(model, exp, args) for exp in exposures]).T\n\n    return {\n        \"likelihoods\": balances[0],\n        \"priors\": balances[1],\n        \"exp_keys\": [exp.key for exp in exposures],\n        \"args\": args,\n    }\n</code></pre>"},{"location":"docs/api/#dorito.stats.disco_regularised_loss_fn","title":"<code>disco_regularised_loss_fn(model, exposure, args={'reg_dict': {}})</code>","text":"<p>Compute a regularised loss for interferometric (DISCO) data.</p> <p>The returned value mirrors other loss wrappers and returns a scalar plus an empty tuple for compatibility with calling code.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def disco_regularised_loss_fn(model, exposure, args={\"reg_dict\": {}}):\n    \"\"\"Compute a regularised loss for interferometric (DISCO) data.\n\n    The returned value mirrors other loss wrappers and returns a scalar plus\n    an empty tuple for compatibility with calling code.\n    \"\"\"\n\n    # regular likelihood term\n    likelihood = oi_log_likelihood(model, exposure)\n\n    # grabbing and exponentiating log distributions\n    prior = apply_regularisers(model, exposure, args)\n\n    return likelihood + prior, ()\n</code></pre>"},{"location":"docs/api/#dorito.stats.oi_log_likelihood","title":"<code>oi_log_likelihood(model, oi)</code>","text":"<p>Compute a Gaussian negative log-likelihood for OI data.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>Model object callable as <code>oi(model)</code> to return model predictions.</p> required <code>oi</code> <code>object</code> <p>Object exposing <code>vis</code>, <code>phi</code>, <code>d_vis</code> and <code>d_phi</code> arrays.</p> required Source code in <code>src/dorito/stats.py</code> <pre><code>def oi_log_likelihood(model, oi):\n    \"\"\"Compute a Gaussian negative log-likelihood for OI data.\n\n    Parameters\n    ----------\n    model : object\n        Model object callable as ``oi(model)`` to return model predictions.\n    oi : object\n        Object exposing ``vis``, ``phi``, ``d_vis`` and ``d_phi`` arrays.\n    \"\"\"\n    data = np.concatenate([oi.vis, oi.phi])\n    err = np.concatenate([oi.d_vis, oi.d_phi])\n    model_vis = oi(model)\n\n    residual = data - model_vis\n    nll = np.sum(0.5 * (residual / err) ** 2 + np.log(err * np.sqrt(2 * np.pi)))\n\n    return nll\n</code></pre>"},{"location":"docs/api/#plotting","title":"Plotting","text":"<p>Plotting helpers used by notebooks and examples.</p> <p>This module provides small convenience functions for common plotting tasks used across the dorito examples, such as plotting the diffraction-limit scale bar, computing axis extents in arcseconds and a standard image plotting function that handles normalization, rotation and optional scale bars.</p>"},{"location":"docs/api/#dorito.plotting.plot_diffraction_limit","title":"<code>plot_diffraction_limit(model, ax=None, OOP=False)</code>","text":"<p>Plot a scale bar showing the diffraction limit (lambda / D).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>Object exposing <code>source_spectrum</code> and <code>optics.diameter</code> used to compute an effective wavelength and the diffraction-limited scale.</p> required <code>ax</code> <code>Axes</code> <p>Axis to draw onto. If not provided, the function draws to the current pyplot axes.</p> <code>None</code> <code>OOP</code> <code>bool</code> <p>If True and <code>ax</code> is provided, draw the bar on the supplied axis and return the axis.</p> <code>False</code> Source code in <code>src/dorito/plotting.py</code> <pre><code>def plot_diffraction_limit(model, ax=None, OOP=False):\n    \"\"\"Plot a scale bar showing the diffraction limit (lambda / D).\n\n    Parameters\n    ----------\n    model\n        Object exposing ``source_spectrum`` and ``optics.diameter`` used to\n        compute an effective wavelength and the diffraction-limited scale.\n    ax : matplotlib.axes.Axes, optional\n        Axis to draw onto. If not provided, the function draws to the current\n        pyplot axes.\n    OOP : bool, optional\n        If True and ``ax`` is provided, draw the bar on the supplied axis and\n        return the axis.\n    \"\"\"\n    effective_wl = np.dot(model.source_spectrum.wavelengths, model.source_spectrum.weights)\n    diff_lim = dlu.rad2arcsec(effective_wl / model.optics.diameter)\n    scale_length = diff_lim\n\n    scale_bar_x = -0.7\n    scale_bar_y = scale_bar_x\n    fontdict = {\n        \"fontstyle\": \"normal\",\n        \"color\": \"hotpink\",\n        \"weight\": \"demi\",\n        \"size\": 7,\n    }\n\n    if OOP and ax is not None:\n        ax.plot(\n            [scale_bar_x, scale_bar_x + scale_length],\n            [scale_bar_y, scale_bar_y],\n            color=\"hotpink\",\n            linewidth=2,\n        )\n        ax.text(\n            scale_bar_x + scale_length / 2 - 0.075,\n            scale_bar_y + 0.03,\n            r\"$\\lambda / D$\",\n            **fontdict,\n        )\n        return ax\n\n    else:\n        plt.plot(\n            [scale_bar_x, scale_bar_x + scale_length],\n            [scale_bar_y, scale_bar_y],\n            color=\"hotpink\",\n            linewidth=2,\n        )\n        plt.text(\n            scale_bar_x + scale_length / 2 - 0.046,\n            scale_bar_y + 0.02,\n            r\"$\\lambda / D$\",\n            **fontdict,\n        )\n</code></pre>"},{"location":"docs/api/#dorito.plotting.get_arcsec_extents","title":"<code>get_arcsec_extents(pixel_scale, shape)</code>","text":"<p>Return axis extents in arcseconds for use with <code>imshow</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_scale</code> <code>float</code> <p>Pixel scale in arcseconds per pixel.</p> required <code>shape</code> <code>tuple</code> <p>Shape of the image (ny, nx) or (n, n). The function uses the first axis length to compute the extent.</p> required Source code in <code>src/dorito/plotting.py</code> <pre><code>def get_arcsec_extents(pixel_scale, shape):\n    \"\"\"Return axis extents in arcseconds for use with ``imshow``.\n\n    Parameters\n    ----------\n    pixel_scale : float\n        Pixel scale in arcseconds per pixel.\n    shape : tuple\n        Shape of the image (ny, nx) or (n, n). The function uses the first\n        axis length to compute the extent.\n    \"\"\"\n    return np.array([0.5, -0.5, -0.5, 0.5]) * pixel_scale * shape[0]\n</code></pre>"},{"location":"docs/api/#dorito.plotting.plot_result","title":"<code>plot_result(ax, array, pixel_scale, roll_angle_degrees=None, cmap='afmhot_10u', bg_color='k', axis_labels={'xlabel': '$\\\\Delta$RA [arcsec]', 'ylabel': '$\\\\Delta$DEC [arcsec]'}, norm=mpl.colors.PowerNorm(1, vmin=0, vmax=None), diff_lim=None, scale=1.0, translate=(0.0, 0.0), ticks=[0.5, 0, -0.5])</code>","text":"<p>Convenience wrapper to display an image with sensible defaults.</p> <p>This helper sets axis labels, background colour, computes an extent in arcseconds from the provided <code>pixel_scale</code> and applies optional rotation and scaling to the resulting image artist.</p> Source code in <code>src/dorito/plotting.py</code> <pre><code>def plot_result(\n    ax,\n    array,\n    pixel_scale,\n    roll_angle_degrees: float = None,\n    cmap: str = \"afmhot_10u\",\n    bg_color: str = \"k\",\n    axis_labels: dict = {\n        \"xlabel\": r\"$\\Delta$RA [arcsec]\",\n        \"ylabel\": r\"$\\Delta$DEC [arcsec]\",\n    },\n    norm=mpl.colors.PowerNorm(1, vmin=0, vmax=None),\n    diff_lim: float = None,\n    scale=1.0,\n    translate=(0.0, 0.0),\n    ticks=[0.5, 0, -0.5],\n):\n    \"\"\"Convenience wrapper to display an image with sensible defaults.\n\n    This helper sets axis labels, background colour, computes an extent in\n    arcseconds from the provided `pixel_scale` and applies optional rotation\n    and scaling to the resulting image artist.\n    \"\"\"\n\n    ax.set_facecolor(bg_color)  # Set the background colour\n    ax.tick_params(direction=\"out\")\n    ax.set(\n        xticks=ticks,\n        yticks=ticks[::-1],\n        **axis_labels,\n    )  # Set the axis labels\n\n    kwargs = {\n        \"cmap\": cmap,\n        \"extent\": get_arcsec_extents(pixel_scale / scale, array.shape),\n        \"norm\": norm,\n        \"aspect\": \"equal\",\n    }\n\n    im = ax.imshow(\n        array,\n        **kwargs,\n    )\n\n    if diff_lim is not None:\n\n        centre = 0.95 * np.array(kwargs[\"extent\"][0:2]) + np.array([-diff_lim, diff_lim])\n\n        beam = mpl.patches.Circle(\n            centre,\n            radius=diff_lim,\n            facecolor=\"white\",\n            edgecolor=\"black\",\n            alpha=0.7,\n            zorder=10,\n        )\n        ax.add_patch(beam)\n\n    if roll_angle_degrees is not None or scale is not None:\n\n        if scale is None:\n            scale = 1.0\n        if roll_angle_degrees is None:\n            roll_angle_degrees = 0.0\n\n        rotation_transform = (\n            mpl.transforms.Affine2D()\n            .rotate_deg(roll_angle_degrees)\n            .scale(scale)\n            .translate(*translate)\n        )  # Create a rotation transformation\n        trans_data = rotation_transform + ax.transData  # creating transformation\n        im.set_transform(trans_data)  # applying transformation to image\n\n    return im\n</code></pre>"},{"location":"docs/api/#misc","title":"Misc","text":"<p>Small miscellaneous helpers used in examples and notebooks.</p> <p>The utilities here are lightweight helpers that operate on the simple file structures used across the dorito examples (for example calslope-like objects) and a couple of geometry helpers used when building model inputs.</p>"},{"location":"docs/api/#dorito.misc.truncate_files","title":"<code>truncate_files(files, ngroups)</code>","text":"<p>Truncate the ramp of files to only have ngroups. This is use for saturated or highly nonlinear data where you want to discard the top of the ramp.</p> <p>This modifies the list of file-like objects in-place by trimming the top groups from the arrays stored under keys like <code>RAMP</code> / <code>SLOPE</code> and their covariance counterparts.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list</code> <p>Sequence of file-like objects where attributes such as <code>RAMP</code> and <code>SLOPE</code> provide <code>.data</code> arrays whose first axis indexes groups.</p> required <code>ngroups</code> <code>int</code> <p>Number of groups to preserve at the start of the ramp.</p> required Source code in <code>src/dorito/misc.py</code> <pre><code>def truncate_files(files, ngroups):\n    \"\"\"Truncate the ramp of files to only have ngroups. This is use for\n    saturated or highly nonlinear data where you want to discard the top of\n    the ramp.\n\n    This modifies the list of file-like objects in-place by trimming the top\n    groups from the arrays stored under keys like ``RAMP`` / ``SLOPE`` and\n    their covariance counterparts.\n\n    Parameters\n    ----------\n    files : list\n        Sequence of file-like objects where attributes such as ``RAMP`` and\n        ``SLOPE`` provide ``.data`` arrays whose first axis indexes groups.\n    ngroups : int\n        Number of groups to preserve at the start of the ramp.\n    \"\"\"\n\n    for file in files:\n\n        # grabbing the total number of groups in the ramp\n        top_group = file[\"RAMP\"].data.shape[0]\n        up_to = top_group - ngroups\n\n        # files are mutable, so they will change in place\n        for attr in [\"RAMP\", \"SLOPE\", \"RAMP_SUP\", \"SLOPE_SUP\"]:\n            file[attr].data = file[attr].data[:-up_to, ...]\n        for attr in [\"RAMP_COV\", \"SLOPE_COV\"]:\n            file[attr].data = file[attr].data[:-up_to, :-up_to, ...]\n</code></pre>"},{"location":"docs/api/#dorito.misc.fwhm_to_sigma","title":"<code>fwhm_to_sigma(fwhm)</code>","text":"<p>Convert FWHM to sigma for a Gaussian distribution.</p> <p>Parameters:</p> Name Type Description Default <code>fwhm</code> <code>float</code> <p>Full width at half maximum.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Corresponding standard deviation (sigma).</p> Source code in <code>src/dorito/misc.py</code> <pre><code>def fwhm_to_sigma(fwhm):\n    \"\"\"\n    Convert FWHM to sigma for a Gaussian distribution.\n\n    Parameters\n    ----------\n    fwhm : float\n        Full width at half maximum.\n    Returns\n    -------\n    float\n        Corresponding standard deviation (sigma).\n    \"\"\"\n    return fwhm / (2 * np.sqrt(2 * np.log(2)))\n</code></pre>"},{"location":"docs/api/#dorito.misc.calc_parang","title":"<code>calc_parang(file)</code>","text":"<p>Return the parallactic/roll angle extracted from a file header.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>mapping - like</code> <p>File-like object with a <code>PRIMARY</code> header containing <code>ROLL_REF</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Numeric parallactic/roll angle.</p> Source code in <code>src/dorito/misc.py</code> <pre><code>def calc_parang(file):\n    \"\"\"Return the parallactic/roll angle extracted from a file header.\n\n    Parameters\n    ----------\n    file : mapping-like\n        File-like object with a ``PRIMARY`` header containing ``ROLL_REF``.\n\n    Returns\n    -------\n    ndarray\n        Numeric parallactic/roll angle.\n    \"\"\"\n    return np.array(file[\"PRIMARY\"].header[\"ROLL_REF\"])\n</code></pre>"},{"location":"docs/api/","title":"API Reference","text":"<p>This section contains API reference pages for each <code>dorito</code> submodule.</p> <ul> <li>Bases</li> <li>Models</li> <li>Model Fits</li> <li>Plotting</li> <li>Stats</li> <li>Misc</li> </ul> <p>Each page is generated from the package docstrings using <code>mkdocstrings</code>.</p>"},{"location":"docs/api/bases/","title":"bases","text":"<p>Utilities for image basis transforms and small helpers.</p> <p>Full API</p>"},{"location":"docs/api/bases/#dorito.bases.ImageBasis","title":"<code>ImageBasis</code>","text":"<p>               Bases: <code>Base</code></p> <p>Linear image basis wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>transform_matrix</code> <code>Array</code> <p>Matrix that maps basis coefficients to flattened image pixels. The class stores the forward matrix <code>M</code> and a pseudo-inverse <code>M_inv</code> used to move between pixel and basis representations.</p> required Notes <p>The class intentionally accepts non-orthogonal bases and computes the pseudo-inverse when <code>ortho=False</code>.</p> Source code in <code>src/dorito/bases.py</code> <pre><code>class ImageBasis(Base):\n    \"\"\"Linear image basis wrapper.\n\n    Parameters\n    ----------\n    transform_matrix\n        Matrix that maps basis coefficients to flattened image pixels. The\n        class stores the forward matrix `M` and a pseudo-inverse `M_inv` used\n        to move between pixel and basis representations.\n\n    Notes\n    -----\n    The class intentionally accepts non-orthogonal bases and computes the\n    pseudo-inverse when `ortho=False`.\n    \"\"\"\n\n    M: Array\n    M_inv: Array\n    n_basis: int = eqx.field(static=True)\n    size: int = eqx.field(static=True)\n\n    def __init__(self, transform_matrix: Array, n_basis: int = None, ortho=False):\n        if n_basis is None:\n            n_basis = transform_matrix.shape[1]\n        self.n_basis = n_basis\n        self.M = transform_matrix[:, :n_basis]\n        if ortho:\n            self.M_inv = self.M.T\n        else:\n            self.M_inv = np.linalg.pinv(self.M)\n        self.size = int(np.sqrt(self.M.shape[0]))\n\n    def to_basis(self, img: Array) -&gt; Array:\n        \"\"\"Project a 2D image into the basis and return coefficients.\n\n        Parameters\n        ----------\n        img : Array\n            2D image array with shape (size, size).\n\n        Returns\n        -------\n        Array\n            Basis coefficients (flattened).\n        \"\"\"\n        return np.dot(self.M_inv, img.flatten())\n\n    def from_basis(self, coeffs: Array) -&gt; Array:\n        \"\"\"Reconstruct an image from basis coefficients.\n\n        Parameters\n        ----------\n        coeffs : Array\n            Basis coefficients.\n\n        Returns\n        -------\n        Array\n            2D image reconstructed from the provided coefficients.\n        \"\"\"\n        return np.dot(self.M, coeffs).reshape((self.size, self.size))\n</code></pre>"},{"location":"docs/api/bases/#dorito.bases.ImageBasis.to_basis","title":"<code>to_basis(img)</code>","text":"<p>Project a 2D image into the basis and return coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>Array</code> <p>2D image array with shape (size, size).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Basis coefficients (flattened).</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def to_basis(self, img: Array) -&gt; Array:\n    \"\"\"Project a 2D image into the basis and return coefficients.\n\n    Parameters\n    ----------\n    img : Array\n        2D image array with shape (size, size).\n\n    Returns\n    -------\n    Array\n        Basis coefficients (flattened).\n    \"\"\"\n    return np.dot(self.M_inv, img.flatten())\n</code></pre>"},{"location":"docs/api/bases/#dorito.bases.ImageBasis.from_basis","title":"<code>from_basis(coeffs)</code>","text":"<p>Reconstruct an image from basis coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>Array</code> <p>Basis coefficients.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>2D image reconstructed from the provided coefficients.</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def from_basis(self, coeffs: Array) -&gt; Array:\n    \"\"\"Reconstruct an image from basis coefficients.\n\n    Parameters\n    ----------\n    coeffs : Array\n        Basis coefficients.\n\n    Returns\n    -------\n    Array\n        2D image reconstructed from the provided coefficients.\n    \"\"\"\n    return np.dot(self.M, coeffs).reshape((self.size, self.size))\n</code></pre>"},{"location":"docs/api/bases/#dorito.bases.inscribed_circ_basis","title":"<code>inscribed_circ_basis(size, return_window=True)</code>","text":"<p>Create an image basis using pixels inside an inscribed circular window.</p> <p>The function builds a linear basis matrix <code>M</code> that maps basis coefficients to the flattened image pixels for the pixels that lie inside a circular top-hat window inscribed in a square of side <code>size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of pixels on a side of the (square) image. The function constructs a <code>size x size</code> window and selects pixels inside the inscribed top-hat.</p> required <code>return_window</code> <code>bool</code> <p>If True (default) return a tuple <code>(ImageBasis, window_arr)</code> where <code>window_arr</code> is the boolean mask of selected pixels. Otherwise return only the <code>ImageBasis</code> instance.</p> <code>True</code> <p>Returns:</p> Type Description <code>ImageBasis or (ImageBasis, ndarray)</code> <p>The basis mapping (and optionally the boolean window mask).</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def inscribed_circ_basis(size: int, return_window=True) -&gt; Array:\n    \"\"\"Create an image basis using pixels inside an inscribed circular window.\n\n    The function builds a linear basis matrix `M` that maps basis\n    coefficients to the flattened image pixels for the pixels that lie\n    inside a circular top-hat window inscribed in a square of side ``size``.\n\n    Parameters\n    ----------\n    size : int\n        Number of pixels on a side of the (square) image. The function\n        constructs a ``size x size`` window and selects pixels inside the\n        inscribed top-hat.\n    return_window : bool, optional\n        If True (default) return a tuple ``(ImageBasis, window_arr)`` where\n        ``window_arr`` is the boolean mask of selected pixels. Otherwise\n        return only the ``ImageBasis`` instance.\n\n    Returns\n    -------\n    ImageBasis or (ImageBasis, ndarray)\n        The basis mapping (and optionally the boolean window mask).\n    \"\"\"\n\n    window_arr = TopHatWindow(1)((size, size))\n    mask = onp.where(window_arr.flatten())[0]\n    M = onp.eye(size**2)[:, mask]\n    if return_window:\n        return ImageBasis(np.array(M), ortho=True), window_arr\n    return ImageBasis(np.array(M))\n</code></pre>"},{"location":"docs/api/bases/#dorito.bases.inscribed_annulus_basis","title":"<code>inscribed_annulus_basis(size, iterations=2, return_window=True)</code>","text":"<p>Create an image basis for an annulus (inscribed ring) window.</p> <p>Constructs a basis matrix selecting pixels that lie in an annulus defined by subtracting an inner dilated mask from an outer top-hat window. The inner radius is controlled by <code>iterations</code> passed to <code>scipy.ndimage.binary_dilation</code> so larger <code>iterations</code> produce a wider inner hole.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of pixels on a side of the (square) image.</p> required <code>iterations</code> <code>int</code> <p>Number of binary dilation iterations used to build the inner hole (default: 2).</p> <code>2</code> <code>return_window</code> <code>bool</code> <p>If True (default) return a tuple <code>(ImageBasis, window_arr)</code> where <code>window_arr</code> is the boolean mask of selected annulus pixels.</p> <code>True</code> <p>Returns:</p> Type Description <code>ImageBasis or (ImageBasis, ndarray)</code> <p>The basis mapping (and optionally the boolean window mask).</p> Source code in <code>src/dorito/bases.py</code> <pre><code>def inscribed_annulus_basis(size: int, iterations=2, return_window=True) -&gt; Array:\n    \"\"\"Create an image basis for an annulus (inscribed ring) window.\n\n    Constructs a basis matrix selecting pixels that lie in an annulus\n    defined by subtracting an inner dilated mask from an outer top-hat\n    window. The inner radius is controlled by ``iterations`` passed to\n    ``scipy.ndimage.binary_dilation`` so larger ``iterations`` produce a\n    wider inner hole.\n\n    Parameters\n    ----------\n    size : int\n        Number of pixels on a side of the (square) image.\n    iterations : int, optional\n        Number of binary dilation iterations used to build the inner hole\n        (default: 2).\n    return_window : bool, optional\n        If True (default) return a tuple ``(ImageBasis, window_arr)`` where\n        ``window_arr`` is the boolean mask of selected annulus pixels.\n\n    Returns\n    -------\n    ImageBasis or (ImageBasis, ndarray)\n        The basis mapping (and optionally the boolean window mask).\n    \"\"\"\n\n    outer = TopHatWindow(1)((size, size))\n    inner = binary_dilation(\n        np.zeros_like(outer).at[size // 2, size // 2].set(1), iterations=iterations\n    )\n    window_arr = outer - inner\n\n    mask = onp.where(window_arr.flatten())[0]\n    M = onp.eye(size**2)[:, mask]\n    if return_window:\n        return ImageBasis(np.array(M), ortho=True), window_arr\n    return ImageBasis(np.array(M))\n</code></pre>"},{"location":"docs/api/misc/","title":"misc","text":"<p>Small miscellaneous helpers used in examples and notebooks.</p> <p>Full API</p> <p>Small miscellaneous helpers used in examples and notebooks.</p> <p>The utilities here are lightweight helpers that operate on the simple file structures used across the dorito examples (for example calslope-like objects) and a couple of geometry helpers used when building model inputs.</p>"},{"location":"docs/api/misc/#dorito.misc.truncate_files","title":"<code>truncate_files(files, ngroups)</code>","text":"<p>Truncate the ramp of files to only have ngroups. This is use for saturated or highly nonlinear data where you want to discard the top of the ramp.</p> <p>This modifies the list of file-like objects in-place by trimming the top groups from the arrays stored under keys like <code>RAMP</code> / <code>SLOPE</code> and their covariance counterparts.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list</code> <p>Sequence of file-like objects where attributes such as <code>RAMP</code> and <code>SLOPE</code> provide <code>.data</code> arrays whose first axis indexes groups.</p> required <code>ngroups</code> <code>int</code> <p>Number of groups to preserve at the start of the ramp.</p> required Source code in <code>src/dorito/misc.py</code> <pre><code>def truncate_files(files, ngroups):\n    \"\"\"Truncate the ramp of files to only have ngroups. This is use for\n    saturated or highly nonlinear data where you want to discard the top of\n    the ramp.\n\n    This modifies the list of file-like objects in-place by trimming the top\n    groups from the arrays stored under keys like ``RAMP`` / ``SLOPE`` and\n    their covariance counterparts.\n\n    Parameters\n    ----------\n    files : list\n        Sequence of file-like objects where attributes such as ``RAMP`` and\n        ``SLOPE`` provide ``.data`` arrays whose first axis indexes groups.\n    ngroups : int\n        Number of groups to preserve at the start of the ramp.\n    \"\"\"\n\n    for file in files:\n\n        # grabbing the total number of groups in the ramp\n        top_group = file[\"RAMP\"].data.shape[0]\n        up_to = top_group - ngroups\n\n        # files are mutable, so they will change in place\n        for attr in [\"RAMP\", \"SLOPE\", \"RAMP_SUP\", \"SLOPE_SUP\"]:\n            file[attr].data = file[attr].data[:-up_to, ...]\n        for attr in [\"RAMP_COV\", \"SLOPE_COV\"]:\n            file[attr].data = file[attr].data[:-up_to, :-up_to, ...]\n</code></pre>"},{"location":"docs/api/misc/#dorito.misc.fwhm_to_sigma","title":"<code>fwhm_to_sigma(fwhm)</code>","text":"<p>Convert FWHM to sigma for a Gaussian distribution.</p> <p>Parameters:</p> Name Type Description Default <code>fwhm</code> <code>float</code> <p>Full width at half maximum.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Corresponding standard deviation (sigma).</p> Source code in <code>src/dorito/misc.py</code> <pre><code>def fwhm_to_sigma(fwhm):\n    \"\"\"\n    Convert FWHM to sigma for a Gaussian distribution.\n\n    Parameters\n    ----------\n    fwhm : float\n        Full width at half maximum.\n    Returns\n    -------\n    float\n        Corresponding standard deviation (sigma).\n    \"\"\"\n    return fwhm / (2 * np.sqrt(2 * np.log(2)))\n</code></pre>"},{"location":"docs/api/misc/#dorito.misc.calc_parang","title":"<code>calc_parang(file)</code>","text":"<p>Return the parallactic/roll angle extracted from a file header.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>mapping - like</code> <p>File-like object with a <code>PRIMARY</code> header containing <code>ROLL_REF</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Numeric parallactic/roll angle.</p> Source code in <code>src/dorito/misc.py</code> <pre><code>def calc_parang(file):\n    \"\"\"Return the parallactic/roll angle extracted from a file header.\n\n    Parameters\n    ----------\n    file : mapping-like\n        File-like object with a ``PRIMARY`` header containing ``ROLL_REF``.\n\n    Returns\n    -------\n    ndarray\n        Numeric parallactic/roll angle.\n    \"\"\"\n    return np.array(file[\"PRIMARY\"].header[\"ROLL_REF\"])\n</code></pre>"},{"location":"docs/api/model_fits/","title":"model_fits","text":"<p>Fitting helpers and <code>ModelFit</code> subclasses for resolved sources.</p> <p>Full API</p> <p>Fitting helpers and ModelFit subclasses for resolved sources.</p> <p>This module provides ModelFit classes for fitting resolved sources using amigo, including utilities to handle the log distribution parameter, rotation by parallactic angle, and simulation of resolved source interferograms.</p>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedFit","title":"<code>ResolvedFit</code>","text":"<p>               Bases: <code>_BaseResolvedFit</code>, <code>ModelFit</code></p> <p>Model fit for resolved (extended) sources.</p> <p>This class extends :class:<code>amigo.model_fits.ModelFit</code> to add support for a spatial distribution parameter (kept as its base-10 logarithm, stored under the key <code>log_dist</code>). It supplies sensible default initialisation and maps the <code>log_dist</code> parameter into the expected keyed parameter namespace for per-filter fitting.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str or path - like</code> <p>Path to the data file or exposure to be passed to :class:<code>ModelFit</code>.</p> required <code>use_cov</code> <code>bool</code> <p>Whether to use the covariance information from the data, by default <code>True</code>.</p> required Source code in <code>src/dorito/model_fits.py</code> <pre><code>class ResolvedFit(_BaseResolvedFit, ModelFit):\n    \"\"\"Model fit for resolved (extended) sources.\n\n    This class extends :class:`amigo.model_fits.ModelFit` to add support for a\n    spatial distribution parameter (kept as its base-10 logarithm, stored\n    under the key ``log_dist``). It supplies sensible default initialisation\n    and maps the ``log_dist`` parameter into the expected keyed parameter\n    namespace for per-filter fitting.\n\n    Parameters\n    ----------\n    file : str or path-like\n        Path to the data file or exposure to be passed to :class:`ModelFit`.\n    use_cov : bool, optional\n        Whether to use the covariance information from the data, by default\n        ``True``.\n    \"\"\"\n\n    def get_key(self, param):\n        match param:\n            case \"log_dist\":\n                return self.filter\n\n        return super().get_key(param)\n\n    def map_param(self, param):\n        match param:\n            case \"log_dist\":\n                return f\"{param}.{self.get_key(param)}\"\n\n        return super().map_param(param)\n\n    def initialise_params(self, optics, distribution):\n\n        params = super().initialise_params(optics)\n\n        # log distribution\n        params[\"log_dist\"] = (\n            self.get_key(\"log_dist\"),\n            np.log10(distribution / distribution.sum()),\n        )\n\n        return params\n\n    def model_interferogram(\n        self,\n        psf,\n        model,\n        rotate: bool = None,\n    ):\n        return psf.convolve(model.get_distribution(self, rotate=rotate), method=\"fft\")\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.DynamicResolvedFit","title":"<code>DynamicResolvedFit</code>","text":"<p>               Bases: <code>ResolvedFit</code></p> <p>Resolved fit where each exposure has its own distribution.</p> <p>For time-series or sequence data where every exposure can have an independent resolved-source distribution, this class modifies the parameter keying so that distribution parameters are unique per exposure (the key includes the exposure <code>self.key</code> and the filter).</p> Notes <p>Only the keying behaviour differs from :class:<code>ResolvedFit</code> \u2014 the underlying parameter representation and simulation pipeline remain the same.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class DynamicResolvedFit(ResolvedFit):\n    \"\"\"Resolved fit where each exposure has its own distribution.\n\n    For time-series or sequence data where every exposure can have an\n    independent resolved-source distribution, this class modifies the\n    parameter keying so that distribution parameters are unique per\n    exposure (the key includes the exposure ``self.key`` and the filter).\n\n    Notes\n    -----\n    Only the keying behaviour differs from :class:`ResolvedFit` \u2014 the\n    underlying parameter representation and simulation pipeline remain the\n    same.\n    \"\"\"\n\n    def get_key(self, param):\n        match param:\n            case \"log_dist\":\n                return \"_\".join([self.key, self.filter])\n\n        return super().get_key(param)\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.TransformedResolvedFit","title":"<code>TransformedResolvedFit</code>","text":"<p>               Bases: <code>ResolvedFit</code></p> <p>Resolved-source fit using coefficients describing a transformed basis.</p> <p>This variant initialises the <code>log_dist</code> parameter from a set of coefficients (for example a set of basis coefficients or a compressed representation) rather than from an explicit full image distribution.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class TransformedResolvedFit(ResolvedFit):\n    \"\"\"Resolved-source fit using coefficients describing a transformed basis.\n\n    This variant initialises the ``log_dist`` parameter from a set of\n    coefficients (for example a set of basis coefficients or a compressed\n    representation) rather than from an explicit full image distribution.\n\n    \"\"\"\n\n    def initialise_params(self, optics, coeffs):\n\n        params = ModelFit.initialise_params(self, optics)\n\n        # log distribution\n        params[\"log_dist\"] = (self.get_key(\"log_dist\"), coeffs)\n\n        return params\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.PointResolvedFit","title":"<code>PointResolvedFit</code>","text":"<p>               Bases: <code>TransformedResolvedFit</code></p> <p>Resolved fit combining an unresolved point-like component and an extended component.</p> <p>This fit represents the source as a superposition of a point source component and a resolved (extended) component. This is useful for modelling systems like young stars with extended protoplanetary disks.</p> Notes <p>Parameters for building the transformed/resolved component are described on :meth:<code>initialise_params</code> (for example <code>optics</code>, <code>coeffs</code> and <code>contrast</code> are the arguments used when initialising parameters).</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class PointResolvedFit(TransformedResolvedFit):\n    \"\"\"Resolved fit combining an unresolved point-like component and an extended component.\n\n    This fit represents the source as a superposition of a point source\n    component and a resolved (extended) component. This is useful for\n    modelling systems like young stars with extended protoplanetary disks.\n\n    Notes\n    -----\n    Parameters for building the transformed/resolved component are described\n    on :meth:`initialise_params` (for example ``optics``, ``coeffs`` and\n    ``contrast`` are the arguments used when initialising parameters).\n    \"\"\"\n\n    def get_key(self, param):\n\n        match param:\n            case \"contrast\":\n                return self.filter\n\n        return super().get_key(param)\n\n    def map_param(self, param):\n\n        # Map the appropriate parameter to the correct key\n        if param in [\"contrast\"]:\n            return f\"{param}.{self.get_key(param)}\"\n\n        # Else its global\n        return super().map_param(param)\n\n    def initialise_params(self, optics, coeffs, contrast):\n\n        params = ModelFit.initialise_params(self, optics)\n\n        # log distribution\n        params[\"log_dist\"] = (self.get_key(\"log_dist\"), coeffs)\n        params[\"contrast\"] = self.get_key(\"contrast\"), np.array(contrast)\n\n        return params\n\n    def model_interferogram(\n        self,\n        psf,\n        model,\n        rotate: bool = None,\n    ):\n\n        contrast = model.params[\"contrast\"][self.get_key(\"contrast\")]\n        psf1 = psf * (1 - contrast)\n        psf2 = psf * (contrast)\n\n        # convolve source with PSF\n        resolved_component = model.get_distribution(self, rotate=rotate)\n        return psf1 + psf2.convolve(resolved_component, method=\"fft\").data\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit","title":"<code>ResolvedOIFit</code>","text":"<p>               Bases: <code>_OIFit</code>, <code>_BaseResolvedFit</code></p> <p>OI-data backed resolved-source fit utilities.</p> <p>This class mixes the OI-data wrapper behaviour from :class:<code>_OIFit</code> with the resolved-source helpers in :class:<code>_BaseResolvedFit</code>. It provides methods to convert distributions into OTFs/visibilities, produce model DISCO outputs, and compute dirty images usable for visualisation and normalisation.</p> <p>Methods:</p> Name Description <code>initialise_params</code> <p>Prepare <code>log_dist</code> and <code>base_uv</code> parameters for an OI fit.</p> <code>to_otf</code> <p>Return a dLux MFT representing the distribution in OTF space.</p> <code>to_cvis</code> <p>Convert an image distribution into flattened complex visibilities suitable for DISCO-style modelling.</p> <code>dirty_image</code> <p>Compute a dirty image from the underlying observed OI visibilities.</p> <code>__call__</code> <p>Produce the amplitudes/phases used by DISCO from the model distribution.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>class ResolvedOIFit(_OIFit, _BaseResolvedFit):\n    \"\"\"OI-data backed resolved-source fit utilities.\n\n    This class mixes the OI-data wrapper behaviour from :class:`_OIFit` with\n    the resolved-source helpers in :class:`_BaseResolvedFit`. It provides\n    methods to convert distributions into OTFs/visibilities, produce model\n    DISCO outputs, and compute dirty images usable for visualisation and\n    normalisation.\n\n    Methods\n    -------\n    initialise_params(model, distribution)\n        Prepare ``log_dist`` and ``base_uv`` parameters for an OI fit.\n    to_otf(model, distribution)\n        Return a dLux MFT representing the distribution in OTF space.\n    to_cvis(model, distribution)\n        Convert an image distribution into flattened complex visibilities\n        suitable for DISCO-style modelling.\n    dirty_image(...)\n        Compute a dirty image from the underlying observed OI visibilities.\n    __call__(model, rotate=None)\n        Produce the amplitudes/phases used by DISCO from the model\n        distribution.\n    \"\"\"\n\n    def initialise_params(self, model, distribution):\n\n        params = {}  # Initialise an empty dictionary for parameters\n        distribution /= distribution.sum()  # normalise the distribution\n\n        params[\"log_dist\"] = self.get_key(\"log_dist\"), np.log10(distribution)\n        params[\"base_uv\"] = self.get_key(\"base_uv\"), self.get_base_uv(model, distribution.shape[0])\n\n        return params\n\n    def get_key(self, param):\n\n        match param:\n            case \"log_dist\":\n                return self.filter\n            case \"base_uv\":\n                return self.filter  # this is probably unnecessary\n\n    def map_param(self, param):\n\n        # Map the appropriate parameter to the correct key\n        if param in [\"log_dist\", \"base_uv\"]:\n            return f\"{param}.{self.get_key(param)}\"\n\n        # Else its global\n        return param\n\n    def get_base_uv(self, model, n_pix):\n        \"\"\"\n        Get the base uv for normalisation\n\n        Args:\n            model: The model object containing the parameters.\n            n_pix: The number of pixels in one axis of the distribution.\n        Returns:\n            Array: The base UV for normalisation, which is the Fourier transform of a delta function.\n        \"\"\"\n        ind = n_pix // 2\n        base_dist = np.zeros((n_pix, n_pix)).at[ind, ind].set(1.0)\n\n        # base uv for normalisation\n        base_uv = self.to_otf(model, base_dist)\n        return base_uv\n\n    def to_otf(self, model, distribution):\n        \"\"\"\n        Transform the distribution to the OTF plane (Optical Transfer Function).\n        This method performs a Matrix Fourier Transform of the distribution and returns the\n        resulting visibilities in the OTF format.\n        Args:\n            model: The model object containing the parameters.\n            distribution: The distribution of the resolved source.\n        Returns:\n            dlu.MFT: The OTF visibilities as a dLux MFT object.\n        \"\"\"\n\n        return dlu.MFT(\n            phasor=distribution + 0j,\n            wavelength=self.wavel,\n            pixel_scale_in=model.pscale_in,\n            npixels_out=model.uv_npixels,\n            pixel_scale_out=model.uv_pscale,\n            inverse=True,\n        )\n\n    def to_cvis(self, model, distribution):\n        \"\"\"Convert an image distribution into complex visibilities for DISCO.\n\n        The pipeline performed here is:\n        1. Transform the image distribution to the OTF plane via\n           :meth:`to_otf` (a dLux MFT).\n        2. Normalise the complex u,v plane by the stored ``base_uv`` for this\n           fit (see :meth:`initialise_params`).\n        3. Downsample the u,v plane to the DISCO sampling using\n           :func:`dlu.downsample`.\n        4. Flatten the 2D u,v array and return the first half of the vector \u2014\n           for a real-valued image the Fourier transform is Hermitian symmetric\n           and only half the plane is needed.\n\n        Parameters\n        ----------\n        model : object\n            Model object providing UV/OTF parameters and access to\n            ``model.params['base_uv']`` for normalisation.\n        distribution : array-like\n            2D image array (npixels x npixels) describing the resolved source\n            brightness distribution.\n\n        Returns\n        -------\n        numpy.ndarray\n            1-D complex array containing the flattened (half) complex\n            visibilities suitable for DISCO-style modelling.\n\n        Notes\n        -----\n        The returned vector contains only the first half of the flattened\n        u,v array because of u/v symmetry; callers expecting a full u,v\n        representation should reconstruct it using Hermitian symmetry.\n        \"\"\"\n\n        # Perform MFT and move to OTF plane\n        uv = self.to_otf(model, distribution)  # shape (102, 102)\n\n        # Normalise the complex u,v plane\n        uv /= model.params[\"base_uv\"][self.get_key(\"base_uv\")]\n\n        # Downsample to the desired u,v resolution\n        uv = dlu.downsample(uv, 2, mean=True)  # shape (51, 51)\n\n        # flatten and take first half (u,v symmetry)\n        cvis = uv.flatten()[: uv.size // 2]\n\n        return cvis\n\n    def model_disco(self, model, distribution):\n        \"\"\"\n        Compute the model visibilities and phases for the given model object.\n        \"\"\"\n        cvis = self.to_cvis(model, distribution)\n        return self.flatten_model(cvis)\n\n    def dirty_image(\n        self, model, npix=None, rotate=True, otf_support=None, pad=None, pad_value=1 + 0j\n    ):\n        \"\"\"\n        Get the dirty image via MFT. This is the image that would be obtained\n        if the visibilities were directly transformed back to the image plane.\n\n        Args:\n            model: The model object containing the parameters.\n            npix: The number of pixels in one axis of the dirty image.\n                    If None, uses the same size as the model source distribution.\n            rotate: If True, rotates the dirty image by the parallactic angle.\n                    If a float, rotates by that (-'ve) angle in radians.\n        Returns:\n            Array: The dirty image, normalised to sum to 1.\n        \"\"\"\n\n        if npix is None:\n            npix = model.get_distribution(self).shape[0]\n\n        # converting to u,v visibilities\n        log_vis = np.dot(np.linalg.pinv(self.vis_mat), self.vis)\n        phase = np.dot(np.linalg.pinv(self.phi_mat), self.phi)\n        vis_im, phase_im = vis_to_im(log_vis, phase, (51, 51))\n\n        # exponentiating\n        uv = np.exp(vis_im + 1j * phase_im)\n\n        if pad is not None:\n            # Pad the uv visibilities if a pad is specified\n            uv = np.pad(uv, pad_width=pad, mode=\"constant\", constant_values=pad_value)\n\n        # If an OTF support is provided, apply it to the uv visibilities\n        if otf_support is not None:\n            uv *= otf_support\n\n        # Getting the dirty image\n        dirty_image = dlu.MFT(\n            phasor=uv,\n            wavelength=self.wavel,\n            pixel_scale_in=2 * model.uv_pscale,\n            npixels_out=npix,\n            pixel_scale_out=model.pscale_in,\n            inverse=True,\n        )\n\n        # Taking amplitudes\n        dirty_image = np.abs(dirty_image)\n\n        # Optional rotation of the dirty image\n        if rotate:\n            dirty_image = self.rotate(dirty_image)\n\n        # Normalise the image\n        return dirty_image / dirty_image.sum()\n\n    def __call__(self, model, rotate: bool = None):\n        \"\"\"\n        Simulate the DISCOs from the resolved source distribution.\n        This method retrieves the distribution from the model, optionally rotates it,\n        and then computes the DISCOs using the model_disco method.\n        Args:\n            model: The model object containing the parameters.\n            rotate: If True, rotates the distribution by the parallactic angle.\n                    If a float, rotates by that (-'ve) angle in radians.\n        Returns:\n            tuple: A tuple containing the amplitudes and phases in the DISCO basis.\n        \"\"\"\n        # NOTE: Distribution must be odd number of pixels in one axis\n        distribution = model.get_distribution(self, rotate=rotate)\n\n        return self.model_disco(model, distribution=distribution)\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit.get_base_uv","title":"<code>get_base_uv(model, n_pix)</code>","text":"<p>Get the base uv for normalisation</p> <p>Args:     model: The model object containing the parameters.     n_pix: The number of pixels in one axis of the distribution. Returns:     Array: The base UV for normalisation, which is the Fourier transform of a delta function.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def get_base_uv(self, model, n_pix):\n    \"\"\"\n    Get the base uv for normalisation\n\n    Args:\n        model: The model object containing the parameters.\n        n_pix: The number of pixels in one axis of the distribution.\n    Returns:\n        Array: The base UV for normalisation, which is the Fourier transform of a delta function.\n    \"\"\"\n    ind = n_pix // 2\n    base_dist = np.zeros((n_pix, n_pix)).at[ind, ind].set(1.0)\n\n    # base uv for normalisation\n    base_uv = self.to_otf(model, base_dist)\n    return base_uv\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit.to_otf","title":"<code>to_otf(model, distribution)</code>","text":"<p>Transform the distribution to the OTF plane (Optical Transfer Function). This method performs a Matrix Fourier Transform of the distribution and returns the resulting visibilities in the OTF format. Args:     model: The model object containing the parameters.     distribution: The distribution of the resolved source. Returns:     dlu.MFT: The OTF visibilities as a dLux MFT object.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def to_otf(self, model, distribution):\n    \"\"\"\n    Transform the distribution to the OTF plane (Optical Transfer Function).\n    This method performs a Matrix Fourier Transform of the distribution and returns the\n    resulting visibilities in the OTF format.\n    Args:\n        model: The model object containing the parameters.\n        distribution: The distribution of the resolved source.\n    Returns:\n        dlu.MFT: The OTF visibilities as a dLux MFT object.\n    \"\"\"\n\n    return dlu.MFT(\n        phasor=distribution + 0j,\n        wavelength=self.wavel,\n        pixel_scale_in=model.pscale_in,\n        npixels_out=model.uv_npixels,\n        pixel_scale_out=model.uv_pscale,\n        inverse=True,\n    )\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit.to_cvis","title":"<code>to_cvis(model, distribution)</code>","text":"<p>Convert an image distribution into complex visibilities for DISCO.</p> <p>The pipeline performed here is: 1. Transform the image distribution to the OTF plane via    :meth:<code>to_otf</code> (a dLux MFT). 2. Normalise the complex u,v plane by the stored <code>base_uv</code> for this    fit (see :meth:<code>initialise_params</code>). 3. Downsample the u,v plane to the DISCO sampling using    :func:<code>dlu.downsample</code>. 4. Flatten the 2D u,v array and return the first half of the vector \u2014    for a real-valued image the Fourier transform is Hermitian symmetric    and only half the plane is needed.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>Model object providing UV/OTF parameters and access to <code>model.params['base_uv']</code> for normalisation.</p> required <code>distribution</code> <code>array - like</code> <p>2D image array (npixels x npixels) describing the resolved source brightness distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>1-D complex array containing the flattened (half) complex visibilities suitable for DISCO-style modelling.</p> Notes <p>The returned vector contains only the first half of the flattened u,v array because of u/v symmetry; callers expecting a full u,v representation should reconstruct it using Hermitian symmetry.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def to_cvis(self, model, distribution):\n    \"\"\"Convert an image distribution into complex visibilities for DISCO.\n\n    The pipeline performed here is:\n    1. Transform the image distribution to the OTF plane via\n       :meth:`to_otf` (a dLux MFT).\n    2. Normalise the complex u,v plane by the stored ``base_uv`` for this\n       fit (see :meth:`initialise_params`).\n    3. Downsample the u,v plane to the DISCO sampling using\n       :func:`dlu.downsample`.\n    4. Flatten the 2D u,v array and return the first half of the vector \u2014\n       for a real-valued image the Fourier transform is Hermitian symmetric\n       and only half the plane is needed.\n\n    Parameters\n    ----------\n    model : object\n        Model object providing UV/OTF parameters and access to\n        ``model.params['base_uv']`` for normalisation.\n    distribution : array-like\n        2D image array (npixels x npixels) describing the resolved source\n        brightness distribution.\n\n    Returns\n    -------\n    numpy.ndarray\n        1-D complex array containing the flattened (half) complex\n        visibilities suitable for DISCO-style modelling.\n\n    Notes\n    -----\n    The returned vector contains only the first half of the flattened\n    u,v array because of u/v symmetry; callers expecting a full u,v\n    representation should reconstruct it using Hermitian symmetry.\n    \"\"\"\n\n    # Perform MFT and move to OTF plane\n    uv = self.to_otf(model, distribution)  # shape (102, 102)\n\n    # Normalise the complex u,v plane\n    uv /= model.params[\"base_uv\"][self.get_key(\"base_uv\")]\n\n    # Downsample to the desired u,v resolution\n    uv = dlu.downsample(uv, 2, mean=True)  # shape (51, 51)\n\n    # flatten and take first half (u,v symmetry)\n    cvis = uv.flatten()[: uv.size // 2]\n\n    return cvis\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit.model_disco","title":"<code>model_disco(model, distribution)</code>","text":"<p>Compute the model visibilities and phases for the given model object.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def model_disco(self, model, distribution):\n    \"\"\"\n    Compute the model visibilities and phases for the given model object.\n    \"\"\"\n    cvis = self.to_cvis(model, distribution)\n    return self.flatten_model(cvis)\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit.dirty_image","title":"<code>dirty_image(model, npix=None, rotate=True, otf_support=None, pad=None, pad_value=1 + 0j)</code>","text":"<p>Get the dirty image via MFT. This is the image that would be obtained if the visibilities were directly transformed back to the image plane.</p> <p>Args:     model: The model object containing the parameters.     npix: The number of pixels in one axis of the dirty image.             If None, uses the same size as the model source distribution.     rotate: If True, rotates the dirty image by the parallactic angle.             If a float, rotates by that (-'ve) angle in radians. Returns:     Array: The dirty image, normalised to sum to 1.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def dirty_image(\n    self, model, npix=None, rotate=True, otf_support=None, pad=None, pad_value=1 + 0j\n):\n    \"\"\"\n    Get the dirty image via MFT. This is the image that would be obtained\n    if the visibilities were directly transformed back to the image plane.\n\n    Args:\n        model: The model object containing the parameters.\n        npix: The number of pixels in one axis of the dirty image.\n                If None, uses the same size as the model source distribution.\n        rotate: If True, rotates the dirty image by the parallactic angle.\n                If a float, rotates by that (-'ve) angle in radians.\n    Returns:\n        Array: The dirty image, normalised to sum to 1.\n    \"\"\"\n\n    if npix is None:\n        npix = model.get_distribution(self).shape[0]\n\n    # converting to u,v visibilities\n    log_vis = np.dot(np.linalg.pinv(self.vis_mat), self.vis)\n    phase = np.dot(np.linalg.pinv(self.phi_mat), self.phi)\n    vis_im, phase_im = vis_to_im(log_vis, phase, (51, 51))\n\n    # exponentiating\n    uv = np.exp(vis_im + 1j * phase_im)\n\n    if pad is not None:\n        # Pad the uv visibilities if a pad is specified\n        uv = np.pad(uv, pad_width=pad, mode=\"constant\", constant_values=pad_value)\n\n    # If an OTF support is provided, apply it to the uv visibilities\n    if otf_support is not None:\n        uv *= otf_support\n\n    # Getting the dirty image\n    dirty_image = dlu.MFT(\n        phasor=uv,\n        wavelength=self.wavel,\n        pixel_scale_in=2 * model.uv_pscale,\n        npixels_out=npix,\n        pixel_scale_out=model.pscale_in,\n        inverse=True,\n    )\n\n    # Taking amplitudes\n    dirty_image = np.abs(dirty_image)\n\n    # Optional rotation of the dirty image\n    if rotate:\n        dirty_image = self.rotate(dirty_image)\n\n    # Normalise the image\n    return dirty_image / dirty_image.sum()\n</code></pre>"},{"location":"docs/api/model_fits/#dorito.model_fits.ResolvedOIFit.__call__","title":"<code>__call__(model, rotate=None)</code>","text":"<p>Simulate the DISCOs from the resolved source distribution. This method retrieves the distribution from the model, optionally rotates it, and then computes the DISCOs using the model_disco method. Args:     model: The model object containing the parameters.     rotate: If True, rotates the distribution by the parallactic angle.             If a float, rotates by that (-'ve) angle in radians. Returns:     tuple: A tuple containing the amplitudes and phases in the DISCO basis.</p> Source code in <code>src/dorito/model_fits.py</code> <pre><code>def __call__(self, model, rotate: bool = None):\n    \"\"\"\n    Simulate the DISCOs from the resolved source distribution.\n    This method retrieves the distribution from the model, optionally rotates it,\n    and then computes the DISCOs using the model_disco method.\n    Args:\n        model: The model object containing the parameters.\n        rotate: If True, rotates the distribution by the parallactic angle.\n                If a float, rotates by that (-'ve) angle in radians.\n    Returns:\n        tuple: A tuple containing the amplitudes and phases in the DISCO basis.\n    \"\"\"\n    # NOTE: Distribution must be odd number of pixels in one axis\n    distribution = model.get_distribution(self, rotate=rotate)\n\n    return self.model_disco(model, distribution=distribution)\n</code></pre>"},{"location":"docs/api/models/","title":"models","text":"<p>Model primitives and Amigo model subclasses used for resolved sources.</p> <p>Full API</p> <p>Models and Amigo model subclasses used for resolved sources.</p> <p>This module implements resolved-source models for both image plane fitting and interferometric data (DISCO).</p>"},{"location":"docs/api/models/#dorito.models.ResolvedAmigoModel","title":"<code>ResolvedAmigoModel</code>","text":"<p>               Bases: <code>_AmigoModel</code>, <code>_BaseResolvedModel</code></p> <p>Amigo model specialised for resolved (image-plane) sources.</p> <p>This class composes the internal <code>_AmigoModel</code> parameter initialisation behaviour with the <code>_BaseResolvedModel</code> helpers for retrieving a resolved-source distribution. It is the primary model used in the examples to represent a resolved astronomical source for use with the amigo fitting machinery.</p> <p>Parameters:</p> Name Type Description Default <code>exposures</code> <code>sequence</code> <p>Sequence of exposure / fit objects describing each observation.</p> required <code>optics</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>detector</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>ramp_model</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>read</code> <p>Amigo-style objects used to build the forward model (see amigo documentation for expected types).</p> required <code>state</code> <code>mapping</code> <p>Optional calibration state used to override optics/detector/ramp initial values.</p> required <code>rotate</code> <code>bool</code> <p>If True (default) apply exposure rotation to distributions.</p> <code>True</code> <code>source_oversample</code> <code>int</code> <p>Oversampling factor for source-plane operations. When setting an oversampling factor &gt; 1, the optics model must be initialised with an oversample to match (e.g. 3 times source_oversample).</p> <code>1</code> <code>param_initers</code> <code>dict</code> <p>Parameter initialiser values forwarded to exposure initialisation.</p> <code>None</code> Source code in <code>src/dorito/models.py</code> <pre><code>class ResolvedAmigoModel(_AmigoModel, _BaseResolvedModel):\n    \"\"\"Amigo model specialised for resolved (image-plane) sources.\n\n    This class composes the internal `_AmigoModel` parameter initialisation\n    behaviour with the `_BaseResolvedModel` helpers for retrieving a\n    resolved-source distribution. It is the primary model used in the\n    examples to represent a resolved astronomical source for use with the\n    amigo fitting machinery.\n\n    Parameters\n    ----------\n    exposures : sequence\n        Sequence of exposure / fit objects describing each observation.\n    optics, detector, ramp_model, read\n        Amigo-style objects used to build the forward model (see amigo\n        documentation for expected types).\n    state : mapping, optional\n        Optional calibration state used to override optics/detector/ramp\n        initial values.\n    rotate : bool, optional\n        If True (default) apply exposure rotation to distributions.\n    source_oversample : int, optional\n        Oversampling factor for source-plane operations. When setting an\n        oversampling factor &gt; 1, the optics model must be initialised\n        with an oversample to match (e.g. 3 times source_oversample).\n    param_initers : dict, optional\n        Parameter initialiser values forwarded to exposure initialisation.\n    \"\"\"\n\n    source_oversample: int = 1\n\n    def __init__(\n        self,\n        exposures,\n        optics,\n        detector,\n        ramp_model,\n        read,\n        state,\n        rotate: bool = True,\n        source_oversample=1,\n        param_initers: dict = None,\n    ):\n        self.rotate = rotate\n        self.source_oversample = source_oversample\n\n        super().__init__(exposures, optics, detector, ramp_model, read, state, param_initers)\n</code></pre>"},{"location":"docs/api/models/#dorito.models.TransformedResolvedModel","title":"<code>TransformedResolvedModel</code>","text":"<p>               Bases: <code>ResolvedAmigoModel</code></p> <p>Resolved model that stores and operates in a compact image basis.</p> <p>This class wraps a provided <code>ImageBasis</code> object and stores the source distribution as basis coefficients. When initialising, if a <code>distribution</code> is provided in <code>param_initers</code> it is converted to basis coefficients and stored under the <code>coeffs</code> initialiser key.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>ImageBasis</code> <p>Basis object providing <code>to_basis</code> / <code>from_basis</code> conversions.</p> required <code>window</code> <code>Array</code> <p>Optional multiplicative window applied to reconstructed images.</p> <code>None</code> <code>source_oversample</code> <code>int</code> <p>Oversampling factor for source-plane operations.</p> <code>1</code> <code>param_initers</code> <code>dict</code> <p>Parameter initialisers; accepts a <code>distribution</code> entry which will be converted to <code>coeffs</code> via the supplied <code>basis</code>.</p> <code>{}</code> Source code in <code>src/dorito/models.py</code> <pre><code>class TransformedResolvedModel(ResolvedAmigoModel):\n    \"\"\"Resolved model that stores and operates in a compact image basis.\n\n    This class wraps a provided ``ImageBasis`` object and stores the\n    source distribution as basis coefficients. When initialising, if a\n    ``distribution`` is provided in ``param_initers`` it is converted to\n    basis coefficients and stored under the ``coeffs`` initialiser key.\n\n    Parameters\n    ----------\n    basis : ImageBasis\n        Basis object providing ``to_basis`` / ``from_basis`` conversions.\n    window : Array, optional\n        Optional multiplicative window applied to reconstructed images.\n    source_oversample : int, optional\n        Oversampling factor for source-plane operations.\n    param_initers : dict, optional\n        Parameter initialisers; accepts a ``distribution`` entry which will\n        be converted to ``coeffs`` via the supplied ``basis``.\n    \"\"\"\n\n    basis: None\n    window: Array\n\n    def __init__(\n        self,\n        exposures,\n        optics,\n        detector,\n        ramp_model,\n        read,\n        basis: ImageBasis,\n        state,\n        source_oversample=1,\n        window: Array = None,\n        param_initers: dict = {},\n        rotate: bool = True,\n    ):\n\n        # This seems to fix some recompile issues\n        def fn(x):\n            if isinstance(x, Array):\n                if \"i\" in x.dtype.str:\n                    return x\n                return np.array(x, dtype=float)\n            return x\n\n        self.basis = jtu.map(lambda x: fn(x), basis)\n        self.window = window\n\n        if \"distribution\" in param_initers.keys():\n            init_log_dist = np.log10(param_initers[\"distribution\"])\n            init_coeffs = self.basis.to_basis(init_log_dist)\n            param_initers[\"coeffs\"] = init_coeffs\n            del param_initers[\"distribution\"]\n\n        super().__init__(\n            exposures,\n            optics,\n            detector,\n            ramp_model,\n            read,\n            state,\n            rotate,\n            source_oversample,\n            param_initers,\n        )\n\n    def get_distribution(\n        self,\n        exposure,\n        rotate: bool = None,\n        exponentiate=True,\n        window=True,\n    ):\n\n        coeffs = self.params[\"log_dist\"][exposure.get_key(\"log_dist\")]\n\n        # exponentiation\n        if exponentiate:\n            distribution = 10 ** self.basis.from_basis(coeffs)\n        else:\n            distribution = self.basis.from_basis(coeffs)\n\n        # windowing\n        if self.window is not None and window:\n            distribution *= self.window\n\n        # rotation\n        if rotate is None:\n            rotate = self.rotate\n        if rotate:\n            distribution = exposure.rotate(distribution)\n\n        return distribution\n</code></pre>"},{"location":"docs/api/models/#dorito.models.ResolvedDiscoModel","title":"<code>ResolvedDiscoModel</code>","text":"<p>               Bases: <code>_BaseResolvedModel</code></p> <p>Resolved-source model container for DISCO / interferometric fits.</p> <p>This lightweight container holds parameters required to transform an image-plane distribution into the complex visibilities used by the DISCO-style fitting code. The constructor collects per-oi parameters by calling each <code>oi.initialise_params(self, distribution)</code> and assembling a parameter mapping compatible with the rest of the amigo pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>ois</code> <code>list</code> <p>List of OI-like exposure objects providing <code>initialise_params</code> and other data accessors used during fitting.</p> required <code>distribution</code> <code>Array</code> <p>Initial image-plane distribution used to derive initial parameters.</p> required <code>uv_npixels</code> <code>int</code> <p>Number of pixels in the output u/v plane used for transforms.</p> required <code>uv_pscale</code> <code>float</code> <p>Pixel scale in the u/v plane.</p> required <code>oversample</code> <code>float</code> <p>Image-plane oversampling factor used by the model (default: 1.0).</p> <code>1.0</code> <code>psf_pixel_scale</code> <code>float</code> <p>PSF pixel scale in arcseconds per pixel (default chosen for examples).</p> <code>0.065524085</code> <code>rotate</code> <code>bool</code> <p>If True, model-dirty images and transforms will be rotated by the exposure parallactic angle when requested.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>pscale_in</code> <code>float</code> <p>Property returning the image-plane pixel scale in radians per pixel.</p> Source code in <code>src/dorito/models.py</code> <pre><code>class ResolvedDiscoModel(_BaseResolvedModel):\n    \"\"\"Resolved-source model container for DISCO / interferometric fits.\n\n    This lightweight container holds parameters required to transform an\n    image-plane distribution into the complex visibilities used by the\n    DISCO-style fitting code. The constructor collects per-oi parameters by\n    calling each `oi.initialise_params(self, distribution)` and assembling a\n    parameter mapping compatible with the rest of the amigo pipeline.\n\n    Parameters\n    ----------\n    ois : list\n        List of OI-like exposure objects providing `initialise_params` and\n        other data accessors used during fitting.\n    distribution : Array\n        Initial image-plane distribution used to derive initial parameters.\n    uv_npixels : int\n        Number of pixels in the output u/v plane used for transforms.\n    uv_pscale : float\n        Pixel scale in the u/v plane.\n    oversample : float, optional\n        Image-plane oversampling factor used by the model (default: 1.0).\n    psf_pixel_scale : float, optional\n        PSF pixel scale in arcseconds per pixel (default chosen for examples).\n    rotate : bool, optional\n        If True, model-dirty images and transforms will be rotated by the\n        exposure parallactic angle when requested.\n\n    Attributes\n    ----------\n    pscale_in : float\n        Property returning the image-plane pixel scale in radians per pixel.\n    \"\"\"\n\n    uv_npixels: int\n    uv_pscale: float\n    oversample: float\n    psf_pixel_scale: float\n\n    def __init__(\n        self,\n        ois: list,\n        distribution: Array,\n        uv_npixels: int,\n        uv_pscale: float,\n        oversample: float = 1.0,\n        psf_pixel_scale: float = 0.065524085,  # arcsec/pixel\n        rotate: bool = True,\n    ):\n\n        self.uv_npixels = uv_npixels\n        self.oversample = oversample\n        self.uv_pscale = uv_pscale\n        self.psf_pixel_scale = psf_pixel_scale\n        self.rotate = rotate\n\n        params = {}\n        for oi in ois:\n            param_dict = oi.initialise_params(self, distribution)\n            for param, (key, value) in param_dict.items():\n                if param not in params.keys():\n                    params[param] = {}\n                params[param][key] = value\n\n        super().__init__(params)\n\n    @property\n    def pscale_in(self):\n        \"\"\"\n        The pixel scale of the image plane, in radians per pixel.\n        \"\"\"\n        return dlu.arcsec2rad(self.psf_pixel_scale / self.oversample)\n</code></pre>"},{"location":"docs/api/models/#dorito.models.ResolvedDiscoModel.pscale_in","title":"<code>pscale_in</code>  <code>property</code>","text":"<p>The pixel scale of the image plane, in radians per pixel.</p>"},{"location":"docs/api/plotting/","title":"plotting","text":"<p>Plot helpers used in notebooks and examples.</p> <p>Full API</p> <p>Plotting helpers used by notebooks and examples.</p> <p>This module provides small convenience functions for common plotting tasks used across the dorito examples, such as plotting the diffraction-limit scale bar, computing axis extents in arcseconds and a standard image plotting function that handles normalization, rotation and optional scale bars.</p>"},{"location":"docs/api/plotting/#dorito.plotting.plot_diffraction_limit","title":"<code>plot_diffraction_limit(model, ax=None, OOP=False)</code>","text":"<p>Plot a scale bar showing the diffraction limit (lambda / D).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>Object exposing <code>source_spectrum</code> and <code>optics.diameter</code> used to compute an effective wavelength and the diffraction-limited scale.</p> required <code>ax</code> <code>Axes</code> <p>Axis to draw onto. If not provided, the function draws to the current pyplot axes.</p> <code>None</code> <code>OOP</code> <code>bool</code> <p>If True and <code>ax</code> is provided, draw the bar on the supplied axis and return the axis.</p> <code>False</code> Source code in <code>src/dorito/plotting.py</code> <pre><code>def plot_diffraction_limit(model, ax=None, OOP=False):\n    \"\"\"Plot a scale bar showing the diffraction limit (lambda / D).\n\n    Parameters\n    ----------\n    model\n        Object exposing ``source_spectrum`` and ``optics.diameter`` used to\n        compute an effective wavelength and the diffraction-limited scale.\n    ax : matplotlib.axes.Axes, optional\n        Axis to draw onto. If not provided, the function draws to the current\n        pyplot axes.\n    OOP : bool, optional\n        If True and ``ax`` is provided, draw the bar on the supplied axis and\n        return the axis.\n    \"\"\"\n    effective_wl = np.dot(model.source_spectrum.wavelengths, model.source_spectrum.weights)\n    diff_lim = dlu.rad2arcsec(effective_wl / model.optics.diameter)\n    scale_length = diff_lim\n\n    scale_bar_x = -0.7\n    scale_bar_y = scale_bar_x\n    fontdict = {\n        \"fontstyle\": \"normal\",\n        \"color\": \"hotpink\",\n        \"weight\": \"demi\",\n        \"size\": 7,\n    }\n\n    if OOP and ax is not None:\n        ax.plot(\n            [scale_bar_x, scale_bar_x + scale_length],\n            [scale_bar_y, scale_bar_y],\n            color=\"hotpink\",\n            linewidth=2,\n        )\n        ax.text(\n            scale_bar_x + scale_length / 2 - 0.075,\n            scale_bar_y + 0.03,\n            r\"$\\lambda / D$\",\n            **fontdict,\n        )\n        return ax\n\n    else:\n        plt.plot(\n            [scale_bar_x, scale_bar_x + scale_length],\n            [scale_bar_y, scale_bar_y],\n            color=\"hotpink\",\n            linewidth=2,\n        )\n        plt.text(\n            scale_bar_x + scale_length / 2 - 0.046,\n            scale_bar_y + 0.02,\n            r\"$\\lambda / D$\",\n            **fontdict,\n        )\n</code></pre>"},{"location":"docs/api/plotting/#dorito.plotting.get_arcsec_extents","title":"<code>get_arcsec_extents(pixel_scale, shape)</code>","text":"<p>Return axis extents in arcseconds for use with <code>imshow</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_scale</code> <code>float</code> <p>Pixel scale in arcseconds per pixel.</p> required <code>shape</code> <code>tuple</code> <p>Shape of the image (ny, nx) or (n, n). The function uses the first axis length to compute the extent.</p> required Source code in <code>src/dorito/plotting.py</code> <pre><code>def get_arcsec_extents(pixel_scale, shape):\n    \"\"\"Return axis extents in arcseconds for use with ``imshow``.\n\n    Parameters\n    ----------\n    pixel_scale : float\n        Pixel scale in arcseconds per pixel.\n    shape : tuple\n        Shape of the image (ny, nx) or (n, n). The function uses the first\n        axis length to compute the extent.\n    \"\"\"\n    return np.array([0.5, -0.5, -0.5, 0.5]) * pixel_scale * shape[0]\n</code></pre>"},{"location":"docs/api/plotting/#dorito.plotting.plot_result","title":"<code>plot_result(ax, array, pixel_scale, roll_angle_degrees=None, cmap='afmhot_10u', bg_color='k', axis_labels={'xlabel': '$\\\\Delta$RA [arcsec]', 'ylabel': '$\\\\Delta$DEC [arcsec]'}, norm=mpl.colors.PowerNorm(1, vmin=0, vmax=None), diff_lim=None, scale=1.0, translate=(0.0, 0.0), ticks=[0.5, 0, -0.5])</code>","text":"<p>Convenience wrapper to display an image with sensible defaults.</p> <p>This helper sets axis labels, background colour, computes an extent in arcseconds from the provided <code>pixel_scale</code> and applies optional rotation and scaling to the resulting image artist.</p> Source code in <code>src/dorito/plotting.py</code> <pre><code>def plot_result(\n    ax,\n    array,\n    pixel_scale,\n    roll_angle_degrees: float = None,\n    cmap: str = \"afmhot_10u\",\n    bg_color: str = \"k\",\n    axis_labels: dict = {\n        \"xlabel\": r\"$\\Delta$RA [arcsec]\",\n        \"ylabel\": r\"$\\Delta$DEC [arcsec]\",\n    },\n    norm=mpl.colors.PowerNorm(1, vmin=0, vmax=None),\n    diff_lim: float = None,\n    scale=1.0,\n    translate=(0.0, 0.0),\n    ticks=[0.5, 0, -0.5],\n):\n    \"\"\"Convenience wrapper to display an image with sensible defaults.\n\n    This helper sets axis labels, background colour, computes an extent in\n    arcseconds from the provided `pixel_scale` and applies optional rotation\n    and scaling to the resulting image artist.\n    \"\"\"\n\n    ax.set_facecolor(bg_color)  # Set the background colour\n    ax.tick_params(direction=\"out\")\n    ax.set(\n        xticks=ticks,\n        yticks=ticks[::-1],\n        **axis_labels,\n    )  # Set the axis labels\n\n    kwargs = {\n        \"cmap\": cmap,\n        \"extent\": get_arcsec_extents(pixel_scale / scale, array.shape),\n        \"norm\": norm,\n        \"aspect\": \"equal\",\n    }\n\n    im = ax.imshow(\n        array,\n        **kwargs,\n    )\n\n    if diff_lim is not None:\n\n        centre = 0.95 * np.array(kwargs[\"extent\"][0:2]) + np.array([-diff_lim, diff_lim])\n\n        beam = mpl.patches.Circle(\n            centre,\n            radius=diff_lim,\n            facecolor=\"white\",\n            edgecolor=\"black\",\n            alpha=0.7,\n            zorder=10,\n        )\n        ax.add_patch(beam)\n\n    if roll_angle_degrees is not None or scale is not None:\n\n        if scale is None:\n            scale = 1.0\n        if roll_angle_degrees is None:\n            roll_angle_degrees = 0.0\n\n        rotation_transform = (\n            mpl.transforms.Affine2D()\n            .rotate_deg(roll_angle_degrees)\n            .scale(scale)\n            .translate(*translate)\n        )  # Create a rotation transformation\n        trans_data = rotation_transform + ax.transData  # creating transformation\n        im.set_transform(trans_data)  # applying transformation to image\n\n    return im\n</code></pre>"},{"location":"docs/api/stats/","title":"stats","text":"<p>Statistical loss functions and regularisers used in model fitting.</p> <p>Full API</p> <p>Statistical loss functions and regularisers used in model fitting.</p> <p>This module collects likelihood wrappers and a set of regulariser loss functions (TV, TSV, L1, L2, Maximum Entropy) used across the fitting utilities. Regularisation functions of the for \"REG_loss\" accept raw arrays, and those of the form \"REG\" accept the common <code>model, exposure</code> pair used by <code>amigo</code>.</p>"},{"location":"docs/api/stats/#dorito.stats.L1_loss","title":"<code>L1_loss(arr)</code>","text":"<p>L1 norm loss for array-like inputs.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def L1_loss(arr):\n    \"\"\"L1 norm loss for array-like inputs.\"\"\"\n    return np.nansum(np.abs(arr))\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.L2_loss","title":"<code>L2_loss(arr)</code>","text":"<p>L2 (quadratic) loss for array-like inputs.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def L2_loss(arr):\n    \"\"\"L2 (quadratic) loss for array-like inputs.\"\"\"\n    return np.nansum(arr**2)\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.tikhinov","title":"<code>tikhinov(arr)</code>","text":"<p>Finite-difference approximation used by several regularisers.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def tikhinov(arr):\n    \"\"\"Finite-difference approximation used by several regularisers.\"\"\"\n    pad_arr = np.pad(arr, 2)  # padding\n    dx = np.diff(pad_arr[0:-1, :], axis=1)\n    dy = np.diff(pad_arr[:, 0:-1], axis=0)\n    return dx**2 + dy**2\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.TV_loss","title":"<code>TV_loss(arr, eps=1e-16)</code>","text":"<p>Total variation (approx.) loss computed from finite differences.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def TV_loss(arr, eps=1e-16):\n    \"\"\"Total variation (approx.) loss computed from finite differences.\"\"\"\n    return np.sqrt(tikhinov(arr) + eps**2).sum()\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.TSV_loss","title":"<code>TSV_loss(arr)</code>","text":"<p>Total squared variation (quadratic) loss.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def TSV_loss(arr):\n    \"\"\"Total squared variation (quadratic) loss.\"\"\"\n    return tikhinov(arr).sum()\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.ME_loss","title":"<code>ME_loss(arr, eps=1e-16)</code>","text":"<p>Maximum-entropy inspired loss (negative entropy of distribution).</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ME_loss(arr, eps=1e-16):\n    \"\"\"Maximum-entropy inspired loss (negative entropy of distribution).\"\"\"\n    P = arr / np.nansum(arr)\n    S = np.nansum(-P * np.log(P + eps))\n    return -S\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.ramp_regularised_loss_fn","title":"<code>ramp_regularised_loss_fn(model, exp, args={'reg_dict': {}})</code>","text":"<p>Compute a regularised negative-log-likelihood for ramp data.</p> <p>Returns the scalar loss for a single exposure and a placeholder tuple (kept for amigo API compatibility).</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ramp_regularised_loss_fn(model, exp, args={\"reg_dict\": {}}):\n    \"\"\"Compute a regularised negative-log-likelihood for ramp data.\n\n    Returns the scalar loss for a single exposure and a placeholder tuple\n    (kept for amigo API compatibility).\n    \"\"\"\n\n    # regular likelihood term\n    likelihood = -np.nanmean(exp.mv_zscore(model))\n    prior = apply_regularisers(model, exp, args) if not exp.calibrator else 0.0\n\n    return likelihood + prior, ()\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.apply_regularisers","title":"<code>apply_regularisers(model, exposure, args)</code>","text":"<p>Apply registered regularisers stored in <code>args['reg_dict']</code>.</p> <p>The expected format of <code>args['reg_dict']</code> is a mapping to pairs <code>(coeff, fun)</code> where <code>fun(model, exposure)</code> returns a scalar regulariser value.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def apply_regularisers(model, exposure, args):\n    \"\"\"Apply registered regularisers stored in ``args['reg_dict']``.\n\n    The expected format of ``args['reg_dict']`` is a mapping to pairs\n    ``(coeff, fun)`` where ``fun(model, exposure)`` returns a scalar regulariser\n    value.\n    \"\"\"\n\n    if \"reg_dict\" not in args.keys():\n        return 0.0\n\n    # evaluating the regularisation term with each for each regulariser\n    priors = [coeff * fun(model, exposure) for coeff, fun in args[\"reg_dict\"].values()]\n\n    # summing the different regularisers\n    return np.array(priors).sum()\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.ramp_posterior_balance","title":"<code>ramp_posterior_balance(model, exp, args={'reg_dict': {}})</code>","text":"<p>Return likelihood and prior separately for an exposure.</p> <p>This is useful for diagnostics and for balancing regularisation strengths (e.g. L-curve construction).</p> <p>Note</p> <p>This may not work for multiple simultaneous regularisers.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ramp_posterior_balance(model, exp, args={\"reg_dict\": {}}):\n    \"\"\"Return likelihood and prior separately for an exposure.\n\n    This is useful for diagnostics and for balancing regularisation strengths\n    (e.g. L-curve construction).\n\n    !!! danger \"Note\"\n        This may not work for multiple simultaneous regularisers.\n    \"\"\"\n\n    # regular likelihood term\n    likelihood = -np.nanmean(exp.mv_zscore(model))\n\n    # evaluating the regularisation term with each for each regulariser\n    priors = [fun(model, exp) for _, fun in args[\"reg_dict\"].values()]\n    prior = np.array(priors).sum()\n\n    return likelihood, prior\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.ramp_posterior_balances","title":"<code>ramp_posterior_balances(model, exposures, args={'reg_dict': {}})</code>","text":"<p>Compute likelihood/prior balances for a collection of exposures.</p> <p>Returns a dict with arrays of likelihoods and priors and the exposure keys for convenience in diagnostics.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def ramp_posterior_balances(model, exposures, args={\"reg_dict\": {}}):\n    \"\"\"Compute likelihood/prior balances for a collection of exposures.\n\n    Returns a dict with arrays of likelihoods and priors and the exposure\n    keys for convenience in diagnostics.\n    \"\"\"\n\n    balances = np.array([ramp_posterior_balance(model, exp, args) for exp in exposures]).T\n\n    return {\n        \"likelihoods\": balances[0],\n        \"priors\": balances[1],\n        \"exp_keys\": [exp.key for exp in exposures],\n        \"args\": args,\n    }\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.disco_regularised_loss_fn","title":"<code>disco_regularised_loss_fn(model, exposure, args={'reg_dict': {}})</code>","text":"<p>Compute a regularised loss for interferometric (DISCO) data.</p> <p>The returned value mirrors other loss wrappers and returns a scalar plus an empty tuple for compatibility with calling code.</p> Source code in <code>src/dorito/stats.py</code> <pre><code>def disco_regularised_loss_fn(model, exposure, args={\"reg_dict\": {}}):\n    \"\"\"Compute a regularised loss for interferometric (DISCO) data.\n\n    The returned value mirrors other loss wrappers and returns a scalar plus\n    an empty tuple for compatibility with calling code.\n    \"\"\"\n\n    # regular likelihood term\n    likelihood = oi_log_likelihood(model, exposure)\n\n    # grabbing and exponentiating log distributions\n    prior = apply_regularisers(model, exposure, args)\n\n    return likelihood + prior, ()\n</code></pre>"},{"location":"docs/api/stats/#dorito.stats.oi_log_likelihood","title":"<code>oi_log_likelihood(model, oi)</code>","text":"<p>Compute a Gaussian negative log-likelihood for OI data.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>Model object callable as <code>oi(model)</code> to return model predictions.</p> required <code>oi</code> <code>object</code> <p>Object exposing <code>vis</code>, <code>phi</code>, <code>d_vis</code> and <code>d_phi</code> arrays.</p> required Source code in <code>src/dorito/stats.py</code> <pre><code>def oi_log_likelihood(model, oi):\n    \"\"\"Compute a Gaussian negative log-likelihood for OI data.\n\n    Parameters\n    ----------\n    model : object\n        Model object callable as ``oi(model)`` to return model predictions.\n    oi : object\n        Object exposing ``vis``, ``phi``, ``d_vis`` and ``d_phi`` arrays.\n    \"\"\"\n    data = np.concatenate([oi.vis, oi.phi])\n    err = np.concatenate([oi.d_vis, oi.d_phi])\n    model_vis = oi(model)\n\n    residual = data - model_vis\n    nll = np.sum(0.5 * (residual / err) ** 2 + np.log(err * np.sqrt(2 * np.pi)))\n\n    return nll\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/","title":"Io Reconstruction in the Image Plane","text":"<p>In this notebook I will run through a basic example of an image reconstruction using Method 1 from the dorito paper.</p> <p>First we import our relevant libraries, and enable 64-bit float precision and (optionally) GPU usage.</p> <pre><code># jax ecosystem\nimport jax\nfrom jax import numpy as np  # apologies for this, but once you go jax you never go back\n\njax.config.update(\"jax_enable_x64\", True)  # using 64-bit precision is necessary\njax.config.update(\"jax_platform_name\", \"gpu\")  # for using GPU (optional)\nprint(jax.local_devices()[0].device_kind)\n</code></pre> <pre><code>NVIDIA GeForce RTX 2080 Ti\n</code></pre> <pre><code>import amigo  # for the amigo base model\nimport dorito  # for image reconstruction\nfrom zodiax.optimisation import sgd, adam  # for gradient descent\n\n# other helpful libraries\nimport os\nfrom dLux import utils as dlu  # for some optics utils functionality\n\n# matplotlib ecosystem\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nplt.rcParams[\"image.cmap\"] = \"inferno\"\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = \"lower\"\nplt.rcParams[\"figure.dpi\"] = 300\nplt.rcParams[\"font.size\"] = 8\nplt.rcParams[\"xtick.direction\"] = \"out\"\nplt.rcParams[\"ytick.direction\"] = \"out\"\n</code></pre> <pre><code>/home/max/miniforge3/envs/newb/lib/python3.13/site-packages/amigo/optical_models.py:1: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools&lt;81.\n  import pkg_resources as pkg\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/#loading-in","title":"Loading in","text":"<p>Here we load in the data and relevant files to run the <code>amigo</code> model.</p> <pre><code>path_to_files = \"/media/morgana1/snert/max/data/\"\n\n# processed \"calslope\" files from the amigo pipeline\ndata_path = os.path.join(path_to_files, \"JWST/IO/calslope/\")\n\n# amigo files\nmodel_cache = os.path.join(path_to_files, \"amigo_files/v_0.0.10/\")\nfisher_path = os.path.join(path_to_files, \"amigo_files/fishers/\")\noutput_path = os.path.join(path_to_files, \"amigo_files/outputs/IO/\")\n\nprint(\"Data files:\")\nprint(os.listdir(data_path), \"\\n\")\nprint(\"Amigo model files:\")\nprint(os.listdir(model_cache), \"\\n\")\n</code></pre> <pre><code>Data files:\n['jw01373017001_04102_00001_nis_calslope.fits', 'jw01373023001_03102_00002_nis_calslope.fits', 'jw01373023001_03102_00003_nis_calslope.fits', 'jw01373023001_03102_00004_nis_calslope.fits', 'jw01373017001_04102_00005_nis_calslope.fits', 'jw01373023001_03102_00001_nis_calslope.fits', 'jw01373017001_04102_00002_nis_calslope.fits', 'jw01373017001_04102_00003_nis_calslope.fits', 'jw01373017001_04102_00004_nis_calslope.fits']\n\nAmigo model files:\n['jacobians.npy', 'calibration.npy', 'vis_basis.npy', 'calibration_2.npy', 'calibration_1.npy', 'im_basis101_1pix_M.npy']\n</code></pre> <p>Now we actually load the fits files, and set the bad pixels we want. We also truncate the ramp because the Io data is saturated, and we want to keep the pixel well depth below the that of data which was used to train the <code>amigo</code> model. </p> <pre><code>EXP_TYPE = \"NIS_AMI\"\nFILTERS = [\n    # \"F480M\",\n    \"F430M\",  # Io only had F430M exposures\n    # \"F380M\",\n]\n\n# Bind file path, type and exposure type\nfile_fn = lambda data_path, filters=FILTERS, **kwargs: amigo.files.get_files(\n    data_path,\n    \"calslope\",\n    EXP_TYPE=EXP_TYPE,\n    FILTER=FILTERS,\n    **kwargs,\n)\n\n# Here we load in the fits files\nfiles = sorted(\n    file_fn(data_path), key=lambda hdu: hdu[0].header.get(\"EXPMID\", float(\"inf\"))\n)\n\nsci_files = []\ncal_files = []\n\n# Here we manually set bad pixels in the BADPIX extension of the fits files\nfor file in files:\n\n    # manual bad pixel correction\n    file[\"BADPIX\"].data[58, 67] = 1\n    file[\"BADPIX\"].data[71, 22] = 1\n    file[\"BADPIX\"].data[65, 41] = 1\n    file[\"BADPIX\"].data[35, 70] = 1\n    file[\"BADPIX\"].data[70, 55] = 1\n    file[\"BADPIX\"].data[5, 5] = 1\n    file[\"BADPIX\"].data[-4, 37] = 1\n    file[\"BADPIX\"].data[51, 27] = 1\n    file[\"BADPIX\"].data[28, 18] = 1\n    file[\"BADPIX\"].data[32, 10] = 1\n\n    # edge bad pixels\n    file[\"BADPIX\"].data[:, :3] = 1\n    file[\"BADPIX\"].data[:, -3:] = 1\n    file[\"BADPIX\"].data[:3, :] = 1\n    file[\"BADPIX\"].data[-3:, :] = 1\n\n    if not bool(file[0].header[\"IS_PSF\"]):\n        file[\"BADPIX\"].data[43, 45] = 1\n        file[\"BADPIX\"].data[:, :10] = 1\n        file[\"BADPIX\"].data[:, -10:] = 1\n        file[\"BADPIX\"].data[:10, :] = 1\n        file[\"BADPIX\"].data[-10:, :] = 1\n        sci_files.append(file)\n    elif bool(file[0].header[\"IS_PSF\"]):\n        file[0].header[\"TARGPROP\"] = \"HD 228337\"\n        cal_files.append(file)\n    else:\n        print(f\"Unkown target: {file[0].header['TARGPROP']}\")\n\n# Here we truncate the ramp to keen the pixel well depth under 30k\ndorito.misc.truncate_files(sci_files, 18)\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/#building-the-model","title":"Building the model","text":"<p>We are going to have to build the exposures. <code>dorito</code> has a <code>ResolvedFit</code> class built in, however this will jointly fit all exposures of the same filter. Since we want to capture Io's rotation in a time series, we instead want to uniquely fit each epoch. To do this, we will write a child class of <code>ResolvedFit</code> and amend the <code>get_key</code> method. By adding the <code>self.key</code> to the <code>log_dist</code> parameter key, this ensures each exposure will fit a unique distribution. In the <code>ResolvedFit</code> class, it is instead set just to <code>self.filter</code>, which is common for all the exposures and hence they will share the same parameter.</p> <p><code>DynamicResolvedFit</code> is also built into <code>dorito</code>, but it is useful to show how the classes are constructed. Once you get comfortable with setting the <code>get_key</code> class, <code>amigo</code> makes it very easy to quickly change the parameter fitting hierarchy.</p> <pre><code>class DynamicResolvedFit(dorito.model_fits.ResolvedFit):\n    \"\"\"\n    Model fit for resolved sources where each exposure has a different\n    intensity distribution.\n    \"\"\"\n\n    def get_key(self, param):\n        match param:\n            case \"log_dist\":\n                return \"_\".join([self.key, self.filter])\n\n        return super().get_key(param)\n</code></pre> <p>Now we will build the exposures and model. Today, to keep this simple, we will just fit two of the five Io exposures, and use one of the calibrator exposures.</p> <pre><code>load_dict = lambda x: np.load(f\"{x}\", allow_pickle=True).item()  # helper function\n\n# just two science exposures and one calibrator for this demo\nsci_exps = [DynamicResolvedFit(file) for file in sci_files[0:2]]\ncal_exps = [amigo.model_fits.PointFit(file) for file in cal_files[0:1]]\nexps = sci_exps + cal_exps\n\n# building the model\nsource_size = 101  # pixels\nmodel = dorito.models.ResolvedAmigoModel(\n    exposures=exps,\n    optics=amigo.optical_models.AMIOptics(),\n    detector=amigo.detector_models.LinearDetector(),\n    ramp_model=amigo.ramp_models.NonLinearRamp(),\n    read=amigo.read_models.ReadModel(),\n    state=load_dict(model_cache + \"calibration.npy\"),\n    param_initers={\n        \"distribution\": np.ones((source_size, source_size)) / source_size**2\n    },\n)\n</code></pre> <p>Let's have a look how the model fits the data at our initial guesses (it should be terrible)!</p> <pre><code>for exp in exps:\n    exp.print_summary()\n    amigo.plotting.summarise_fit(model, exp)\n</code></pre> <pre><code>File 01373_017_02_04_1\nStar IO\nFilter F430M\nnints 100\nngroups 18\n</code></pre> <p></p> <pre><code>File 01373_017_02_04_2\nStar IO\nFilter F430M\nnints 100\nngroups 18\n</code></pre> <p></p> <pre><code>File 01373_023_02_03_1\nStar HD 228337\nFilter F430M\nnints 8\nngroups 12\n</code></pre> <p></p>"},{"location":"docs/examples/image_plane_fitting/#optimisation-stage-gradient-descent","title":"Optimisation Stage: Gradient Descent","text":"<p>We now will fit the model using gradient descent, specifically using the <code>optax</code> library. Let's set some things up first.</p> <p>Firstly we have our <code>config</code> dictionary. You can see we are using a mixture of stochastic gradient descent and the adam optimiser. The <code>sgd</code> and <code>adam</code> functions from <code>zodiax</code> are just wrappers around the respective <code>optax</code> functions which allow for easy piecewise learning rate schedules.</p> <p>For example, <code>sgd(lr=100, start=50)</code> will cause a parameter to start fitting after 50 epochs with a learning rate of 100.</p> <pre><code>config = {\n    \"positions\": sgd(lr=4e-2, start=0),\n    \"fluxes\": sgd(2e-2, 0),\n    \"aberrations\": sgd(5e0, 4),\n    \"spectra\": sgd(1e-1, 10),\n    \"log_dist\": adam(5e-2, 20),\n}\n</code></pre> <p>Next we define a <code>norm_fn</code> or normalisation function, and a <code>grad_fn</code> or gradient function. These functions are applied each iteration of the fitting loop to the parameters or the parameter gradients respectively.</p>"},{"location":"docs/examples/image_plane_fitting/#normalisation-function","title":"Normalisation function","text":"<p>Because the source distribution values are covariant with the flux parameter, we want to normalise the source distribution every epoch so it will sum to unity. Additionally, if the <code>spectra</code> parameter wanders outside of \\([-1, 1]\\), everything will turn to <code>NaN</code>. To prevent this, we simply clip the value to \\([-0.8, 0.8]\\) to be extra safe.</p> <pre><code>def norm_fn(model_params, args):\n    params = model_params.params\n    if \"log_dist\" in params.keys():\n        for k, log_dist in params[\"log_dist\"].items():\n            distribution = 10**log_dist\n            params[\"log_dist\"][k] = np.log10(distribution / distribution.sum())\n\n    if \"spectra\" in params.keys():\n        spectra = jax.tree.map(\n            lambda x: np.clip(x, a_min=-0.8, a_max=0.8), params[\"spectra\"]\n        )\n        params[\"spectra\"] = spectra\n\n    return model_params.set(\"params\", params), args\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/#gradient-function","title":"Gradient function","text":"<p>Because we are fitting the Io science exposures separately, they do not mutually constrain the position of the source distribution array. Because of this, we do not fit the positions of the science exposures, as the initial guess will be sufficient to place them in the correct part of the detector. We implement this by simply multiplying the gradients by zero in the <code>grad_fn</code>.</p> <p>I have also observed when fitting Io that the gradients of <code>spectra</code> for the science and calibrator exposures tend to be quite different. Because of this, in the <code>grad_fn</code> I reduce the gradients only for the science exposures by a heuristic factor.</p> <pre><code>sci_pos_keys = []\nsci_spc_keys = []\nfor exp in exps:\n    if not exp.calibrator:\n        sci_pos_keys.append(exp.map_param(\"positions\"))\n        sci_spc_keys.append(exp.map_param(\"spectra\"))\n\n\ndef grad_fn(model, grads, args):\n    # Nuke the position gradients for the science exposures\n    if \"positions\" in config.keys():\n        grads = grads.multiply(sci_pos_keys, 0.0)\n\n    # Reduce spectra gradients for the science exposures\n    if \"spectra\" in config.keys():\n        grads = grads.multiply(sci_spc_keys, 1e-2)\n    return grads, args\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/#regularisation","title":"Regularisation","text":"<p><code>dorito</code> has some common image regularisers built in. Here we will use total variation (<code>dorito.stats.TV</code>), which we put into the <code>args dictionary</code> which we will pass to our <code>Trainer</code> class.</p> <p>For this to work we will need to also pass the <code>dorito.stats.ramp_regularised_loss_fn</code> as the loss function to the <code>Trainer</code> class, as the default <code>amigo</code> loss function knows not of regularisation.</p> <pre><code>args = {\"reg_dict\": {\"TV\": (5e0, dorito.stats.TV)}}\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/#fitting","title":"Fitting","text":"<p>We are almost ready to fit. Here we initialise the <code>Trainer</code> class from <code>amigo</code> and populate the Fisher matrices. These Fisher matrices are not crucial: they are simply pre-calculated matrices which scale the loss space in order to improve convergence, but with plenty of learning rate tweaking you will reach the same result. This is the case for the <code>log_dist</code> parameter which does not have any pre-calculated matrices!</p> <p>Lastly, we perform the fit!</p> <pre><code>n_epoch = 1000\n\ntrainer = amigo.fitting.Trainer(\n    loss_fn=dorito.stats.ramp_regularised_loss_fn,\n    norm_fn=norm_fn,\n    grad_fn=grad_fn,\n    cache=os.path.join(fisher_path),\n)\n\nprint(\"Populating fishers...\")\ntrainer = trainer.populate_fishers(\n    model,\n    exps,\n    hessians=load_dict(model_cache + \"jacobians.npy\")[\"hessian\"],\n    parameters=[p for p in config.keys()],\n)\n\nprint(\"Number of exposures: \", len(exps))\n\n# Train the model\nresult = trainer.train(\n    model=model,\n    optimisers=config,\n    epochs=n_epoch,\n    batches=exps,\n    args=args,\n)\n</code></pre> <pre><code>Populating fishers...\nKeyError: log_dist not in hessians for 01373_017_02_04_1, skipped\nKeyError: log_dist not in hessians for 01373_017_02_04_2, skipped\nKeyError: log_dist not in hessians for 01373_023_02_03_1, skipped\nNumber of exposures:  3\n\n\n\n  0%|          | 0/1000 [00:00&lt;?, ?it/s]\n\n\nCompiling Loss function...\nCompiling update function...\n\nInitial_loss Loss: 120,196.88\nEstimated run time: 0:20:16\nFull Time: 0:21:54\nFinal Loss: 24.42\n</code></pre>"},{"location":"docs/examples/image_plane_fitting/#results","title":"Results","text":"<p>Let's have a look at how our fit went.</p> <pre><code>amigo.plotting.plot_losses(result.losses[0], start=int(n_epoch * 0.75))\namigo.plotting.plot(result.history)\n\nfor exp in exps:\n    exp.print_summary()\n    amigo.plotting.summarise_fit(result.model, exp)\n</code></pre> <p></p> <p></p> <p></p> <p></p> <pre><code>File 01373_017_02_04_1\nStar IO\nFilter F430M\nnints 100\nngroups 18\n</code></pre> <p>Nice. Some of the parameters are not entirely converged, and this can be improved by running the fit for more epochs, or by passing the fit model to another optimiser. We have seen some success with <code>optimistix.BFGS</code>. This is especially true of the <code>spectra</code> parameter for Io, where you can see the effect of spectral miscalibration in the residuals. </p> <p>But this will do nicely for now \u2014 let's see our images!</p> <pre><code>optics_diameter = 6.603464  # JWST aperture diameter in meters\nwavel = 4.3e-6  # approximate F430M mean wavelength in meters\n\nfor idx, exp in enumerate(exps):\n\n    # only plot science exposures\n    if exp.calibrator:\n        continue\n\n    dist = result.model.get_distribution(exp, rotate=False)\n    fig, ax = plt.subplots(figsize=(6, 2.3))\n\n    c0 = dorito.plotting.plot_result(\n        ax,\n        dist / dist.max(),\n        pixel_scale=model.psf_pixel_scale / model.oversample,\n        cmap=\"inferno\",\n        norm=mpl.colors.PowerNorm(0.6, vmin=0, vmax=1.0),\n        diff_lim=0.5 * dlu.rad2arcsec(wavel / optics_diameter),\n        scale=1.2,\n    )\n    fig.colorbar(c0)\n    ax.set(title=f\"Io Frame {idx}\")\n    plt.show()\n</code></pre> <p></p> <p></p> <pre><code>\n</code></pre>"}]}